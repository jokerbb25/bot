from __future__ import annotations

import threading
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Tuple

import MetaTrader5 as mt5
import pandas as pd
import yaml
from ta.trend import ADXIndicator
from ta.volatility import BollingerBands

from utils.indicators import calc_atr, evaluate_indicators
from utils.logger import Logger
from utils.learning import LearningMemory
from telegram_bot import send_message, telegram_listener, BOT_ACTIVE

try:
    import requests
except Exception:  # pragma: no cover
    requests = None


class BotEngine:
    def __init__(
        self,
        gui_log: Optional[Callable[[str], None]] = None,
        config_path: Optional[Path] = None,
        memory_path: Optional[Path] = None,
        status_callback: Optional[Callable[[str], None]] = None,
        confidence_callback: Optional[Callable[[float, str], None]] = None,
        order_callback: Optional[Callable[[Dict[str, Any]], None]] = None,
        stats_callback: Optional[Callable[[Dict[str, Any]], None]] = None,
    ) -> None:
        base_path = Path(__file__).resolve().parent
        self.config_path = config_path or base_path / "config.yaml"
        self.memory_path = memory_path or base_path / "memory.json"
        self.gui_log = gui_log
        self.logger = Logger(gui_log=self.gui_log)
        self.gui = None
        self.status_callback = status_callback
        self.confidence_callback = confidence_callback
        self.order_callback = order_callback
        self.stats_callback = stats_callback

        self.running = threading.Event()
        self._thread: Optional[threading.Thread] = None
        self._thread_lock = threading.Lock()
        self.cycle_lock = threading.Lock()
        self._symbol_lock = threading.Lock()

        self.config = self._load_config()
        self.symbols: List[str] = list(self.config.get("symbols", []))
        self.selected_symbols: List[str] = list(self.symbols)
        self.focus_symbol: Optional[str] = None

        self.timeframe = self._resolve_timeframe(self.config.get("timeframe", "M1"))
        self.poll_interval = float(self.config.get("poll_interval", 1.0))
        self.history_bars = int(self.config.get("history_bars", 500))

        risk_config = self.config.get("risk", {})
        self.lot_high = float(risk_config.get("lot_high", 0.1))
        self.lot_low = float(risk_config.get("lot_low", 0.05))

        confidence_cfg = self.config.get("confidence", {})
        self.base_confidence = float(confidence_cfg.get("base_confidence", 0.7))
        self.lower_confidence = float(confidence_cfg.get("lower_confidence", 0.6))
        self.memory_boost = float(confidence_cfg.get("memory_boost", 0.05))

        self.sl_tp_mode = "Fixed pips"
        self.sl_value = 7.5
        self.tp_value = 15.0
        self.apply_sl_tp_on_pending = True
        self._apply_sl_tp_config_defaults()

        self.memory = LearningMemory(self.memory_path)
        self.strategy_flags: Dict[str, bool] = {
            "rsi_direction": True,
            "ema_trend": True,
            "macd_momentum": True,
            "pullback_signal": True,
            "bollinger_position": True,
            "bollinger_rebound": True,
            "adx_trend": True,
            "volume_spike": True,
            "breakout": True,
            "momentum_candle": True,
            "memory": True,
        }

        self.last_confidence = 0.0
        self.last_candle = None

        self.stats: Dict[str, Any] = {
            "trades": 0,
            "wins": 0,
            "losses": 0,
            "pnl": 0.0,
        }
        self.total_operations = 0
        self._last_ticket_id = 0
        self._telegram_listener_started = False
        self.open_positions: Dict[int, Dict[str, Any]] = {}

    def start(self) -> bool:
        with self._thread_lock:
            if self._thread and self._thread.is_alive():
                self.logger.log("Engine already running.")
                return False
            self._apply_sl_tp_config_defaults()
            self.running.set()
            self._thread = threading.Thread(target=self._run_loop, daemon=True)
            self._thread.start()
            if not self._telegram_listener_started:
                threading.Thread(target=telegram_listener, args=(self,), daemon=True).start()
                self._telegram_listener_started = True
            return True

    def stop(self) -> None:
        with self._thread_lock:
            if not self._thread:
                return
            self.running.clear()
            thread = self._thread
            self._thread = None
        if thread:
            thread.join(timeout=self.poll_interval + 2)

    def set_focus_symbol(self, symbol: str) -> None:
        with self._symbol_lock:
            if symbol in self.symbols:
                self.focus_symbol = symbol
            else:
                self.focus_symbol = None

    def update_selected_symbols(self, symbols: List[str]) -> None:
        with self._symbol_lock:
            valid = [s for s in symbols if s in self.symbols]
            self.selected_symbols = valid if valid else list(self.symbols)

    def update_risk(self, lot_high: float, lot_low: float) -> None:
        self.lot_high = float(max(0.0, lot_high))
        self.lot_low = float(max(0.0, lot_low))

    def update_confidence_levels(self, base: float, lower: float, memory_boost: float) -> None:
        self.base_confidence = float(min(max(base, 0.0), 1.0))
        self.lower_confidence = float(min(max(lower, 0.0), 1.0))
        self.memory_boost = float(min(max(memory_boost, 0.0), 1.0))

    def get_accuracy(self) -> float:
        trades = self.stats.get("trades", 0)
        if trades == 0:
            return 0.0
        wins = self.stats.get("wins", 0)
        return (wins / trades) * 100.0

    def update_strategy(self, name: str, enabled: bool) -> None:
        if name in self.strategy_flags:
            self.strategy_flags[name] = bool(enabled)

    def get_memory_snapshot(self) -> List[Dict[str, Any]]:
        return self.memory.get_patterns()

    def set_sl_tp_mode(self, mode: str) -> None:
        self.sl_tp_mode = str(mode) if mode else "Fixed pips"

    def update_sl_tp_values(self, sl: float, tp: float) -> None:
        self.sl_value = float(sl)
        self.tp_value = float(tp)

    def apply_sl_tp_to_pending(self, enabled: bool) -> None:
        self.apply_sl_tp_on_pending = bool(enabled)

    def _load_config(self) -> Dict[str, Any]:
        if not self.config_path.exists():
            raise FileNotFoundError(f"Config file not found: {self.config_path}")
        with self.config_path.open("r", encoding="utf-8") as handle:
            return yaml.safe_load(handle) or {}

    def _apply_sl_tp_config_defaults(self) -> None:
        cfg = self.config.get("sl_tp", {})
        self.set_sl_tp_mode(cfg.get("mode", "Fixed pips"))
        self.update_sl_tp_values(cfg.get("sl_value", 7.5), cfg.get("tp_value", 15.0))
        self.apply_sl_tp_to_pending(cfg.get("apply_to_pending", True))

    def _run_loop(self) -> None:
        if not mt5.initialize():
            self.logger.log("Failed to connect to MetaTrader5.")
            self._notify_status("Idle")
            return
        self.logger.log("‚úÖ MT5 Connected")
        self.send_telegram("‚úÖ Trading engine started")
        self._notify_status("Scanning")
        try:
            while self.running.is_set():
                self.check_open_positions()
                self.rescue_sl_tp_for_open_positions()
                self.update_gui_positions()
                symbols_to_scan = self._get_symbols_to_scan()
                if not symbols_to_scan:
                    self.logger.log("No symbols configured for scanning.")
                    self.check_open_positions()
                    self.rescue_sl_tp_for_open_positions()
                    self.update_gui_positions()
                    time.sleep(self.poll_interval)
                    continue
                for symbol in symbols_to_scan:
                    if not self.running.is_set():
                        break
                    try:
                        self.scan_symbol(symbol)
                    except Exception as exc:  # pragma: no cover
                        self.logger.log(f"Error in {symbol}: {exc}")
                    time.sleep(0.4)
                self.check_open_positions()
                self.rescue_sl_tp_for_open_positions()
                self.update_gui_positions()
        finally:
            mt5.shutdown()
            self.logger.log("üõë Trading engine stopped ‚Äî MT5 disconnected")
            self.send_telegram("üõë Trading engine stopped ‚Äî MT5 disconnected")
            self._notify_status("Idle")

    def check_open_positions(self) -> None:
        positions = mt5.positions_get()
        active_tickets = {
            int(getattr(pos, "ticket", 0) or 0)
            for pos in positions
        } if positions else set()

        for ticket, trade_data in list(self.open_positions.items()):
            if ticket in active_tickets:
                continue
            pnl_value = self._fetch_closed_pnl(ticket, trade_data)
            symbol = str(trade_data.get("symbol", ""))
            self._handle_closed_trade(symbol, trade_data, pnl_value)
            self.open_positions.pop(ticket, None)

    def _fetch_closed_pnl(self, ticket: int, trade_data: Dict[str, Any]) -> float:
        time.sleep(0.3)
        start_reference = trade_data.get("time")
        if isinstance(start_reference, datetime):
            start_time = max(0.0, start_reference.timestamp() - 86400)
        else:
            start_time = time.time() - 86400
        end_time = time.time()
        history = mt5.history_deals_get(start_time, end_time, ticket=ticket)

        pnl_value = 0.0
        if history is not None and len(history) > 0:
            pnl_value = sum(float(getattr(deal, "profit", 0.0)) for deal in history)
        return pnl_value

    def rescue_sl_tp_for_open_positions(self, sl_distance_points: int = 200, tp_distance_points: int = 400) -> None:
        positions = mt5.positions_get()
        if positions is None or len(positions) == 0:
            return

        for pos in positions:
            try:
                current_sl = float(getattr(pos, "sl", 0.0) or 0.0)
                current_tp = float(getattr(pos, "tp", 0.0) or 0.0)
            except Exception:
                current_sl = 0.0
                current_tp = 0.0
            if current_sl != 0.0 and current_tp != 0.0:
                continue

            symbol = str(getattr(pos, "symbol", ""))
            ticket = int(getattr(pos, "ticket", 0))
            price_open = float(getattr(pos, "price_open", 0.0))
            if ticket <= 0 or not symbol:
                continue

            info = mt5.symbol_info(symbol)
            if info is None:
                continue
            point = float(getattr(info, "point", 0.0) or 0.0)
            stop_level = float(getattr(info, "trade_stops_level", 0.0) or 0.0)
            min_distance = stop_level * point

            sl_distance = max(sl_distance_points * point, min_distance * 2)
            tp_distance = max(tp_distance_points * point, min_distance * 2)

            order_type = int(getattr(pos, "type", mt5.ORDER_TYPE_BUY))
            if order_type == mt5.ORDER_TYPE_BUY:
                sl_price = price_open - sl_distance
                tp_price = price_open + tp_distance
            else:
                sl_price = price_open + sl_distance
                tp_price = price_open - tp_distance

            modify_request = {
                "action": mt5.TRADE_ACTION_SLTP,
                "position": ticket,
                "symbol": symbol,
                "sl": sl_price,
                "tp": tp_price,
            }

            result = mt5.order_send(modify_request)
            if result and getattr(result, "retcode", None) == mt5.TRADE_RETCODE_DONE:
                self.logger.log(f"‚úÖ SL/TP rescue applied [{symbol}] ticket={ticket}")
                if ticket in self.open_positions:
                    self.open_positions[ticket]["sl"] = sl_price
                    self.open_positions[ticket]["tp"] = tp_price
            else:
                retcode = getattr(result, "retcode", "no response")
                self.logger.log(f"‚ö†Ô∏è SL/TP rescue failed [{symbol}] retcode={retcode}")

    def update_gui_positions(self) -> None:
        if not self.gui or not hasattr(self.gui, "update_open_positions"):
            return
        try:
            positions = mt5.positions_get() or []
        except Exception as exc:  # pragma: no cover
            self.logger.log(f"GUI positions refresh failed: {exc}")
            return
        try:
            self.gui.update_open_positions(positions)
        except Exception as exc:  # pragma: no cover
            self.logger.log(f"GUI update failed: {exc}")

    def _handle_closed_trade(self, symbol: str, trade_data: Dict[str, Any], pnl_value: float) -> None:
        result = "WIN" if pnl_value > 0 else "LOSS"
        sign = "+" if pnl_value >= 0 else "-"
        pnl_display = f"{sign}${abs(pnl_value):.2f}"
        message = f"‚úÖ Trade closed [{symbol}] Result: {result} {pnl_display}"
        self.logger.log(message)
        self.send_telegram(message)

        if self.gui:
            if hasattr(self.gui, "update_pnl"):
                try:
                    self.gui.update_pnl(symbol=symbol, result=result, pnl=pnl_value)
                except Exception as exc:  # pragma: no cover
                    self.logger.log(f"GUI update failed: {exc}")
            elif hasattr(self.gui, "update_trade_result"):
                try:
                    self.gui.update_trade_result(symbol=symbol, result=result, pnl=pnl_value)
                except Exception as exc:  # pragma: no cover
                    self.logger.log(f"GUI update failed: {exc}")

        if hasattr(self, "telegram_bot"):
            try:
                self.telegram_bot.send_message(message)
            except Exception as exc:  # pragma: no cover
                self.logger.log(f"Telegram bot send failed: {exc}")

        self._update_stats(result, pnl_value)

        send_message(
            f"Operacion cerrada: #{trade_data.get('ticket', 0)} {symbol}\n"
            f"Resultado: {'WIN ‚úÖ' if result == 'WIN' else 'LOSS ‚ùå'}\n"
            f"Precision Actual: {self.get_accuracy():.2f}%\n"
            f"Pnl: {pnl_value:+.2f} USD"
        )


    def _get_symbols_to_scan(self) -> List[str]:
        with self._symbol_lock:
            ordered = list(self.selected_symbols)
            if self.focus_symbol and self.focus_symbol in ordered:
                ordered.remove(self.focus_symbol)
                return [self.focus_symbol] + ordered
            return ordered

    def scan_symbol(self, symbol: str) -> None:
        if not self.cycle_lock.acquire(blocking=False):
            return
        try:
            df = self._fetch_rates(symbol)
            if df is None or len(df) < 50:
                return
            indicator_flags = {
                "rsi": self.strategy_flags.get("rsi_direction", True),
                "ema": self.strategy_flags.get("ema_trend", True),
                "macd": self.strategy_flags.get("macd_momentum", True),
                "pullback": self.strategy_flags.get("pullback_signal", True),
            }
            analysis = evaluate_indicators(df, strategies=indicator_flags)
            pullback_value = analysis.get("pullback", False)
            if hasattr(pullback_value, "__len__") and not isinstance(pullback_value, (str, bytes)):
                try:
                    pullback_value = bool(list(pullback_value)[-1])
                except Exception:
                    pullback_value = bool(pullback_value)
            pullback_flag = bool(pullback_value)
            analysis["pullback"] = pullback_flag

            close_prices = df["close"].astype(float)
            open_prices = df["open"].astype(float)
            high_prices = df["high"].astype(float)
            low_prices = df["low"].astype(float)
            if "tick_volume" in df.columns:
                volumes = df["tick_volume"].astype(float)
            elif "real_volume" in df.columns:
                volumes = df["real_volume"].astype(float)
            else:
                volumes = pd.Series([0.0] * len(df), index=df.index)

            base_direction = str(analysis.get("direction", "NONE"))
            strategies: List[Tuple[str, str, float]] = []

            rsi_signal = str(analysis.get("rsi_signal", "NONE"))
            ema_trend = str(analysis.get("ema_trend", "flat"))
            ema_signal = "CALL" if ema_trend == "up" else "PUT" if ema_trend == "down" else "NONE"

            if (
                self.strategy_flags.get("rsi_direction", True)
                and self.strategy_flags.get("ema_trend", True)
                and rsi_signal in {"CALL", "PUT"}
                and ema_signal in {"CALL", "PUT"}
                and rsi_signal != ema_signal
            ):
                self.logger.log(f"[{symbol}] ‚ö†Ô∏è Trade skipped ‚Üí RSI and EMA in conflict")
                return

            if self.strategy_flags.get("rsi_direction", True) and rsi_signal in {"CALL", "PUT"}:
                strategies.append(("RSI", rsi_signal, 0.20))

            if self.strategy_flags.get("ema_trend", True) and ema_signal in {"CALL", "PUT"}:
                strategies.append(("EMA Trend", ema_signal, 0.20))

            if self.strategy_flags.get("macd_momentum", True):
                macd_signal = str(analysis.get("macd_signal", "NONE"))
                if macd_signal in {"CALL", "PUT"}:
                    strategies.append(("MACD", macd_signal, 0.20))

            if self.strategy_flags.get("pullback_signal", True) and pullback_flag:
                pullback_direction = base_direction if base_direction in {"CALL", "PUT"} else str(analysis.get("macd_signal", "NONE"))
                if pullback_direction in {"CALL", "PUT"}:
                    strategies.append(("Pullback", pullback_direction, 0.15))

            bollinger_position = str(analysis.get("bollinger_position", "middle"))
            if self.strategy_flags.get("bollinger_position", True):
                if bollinger_position == "lower":
                    strategies.append(("Bollinger Position", "CALL", 0.10))
                elif bollinger_position == "upper":
                    strategies.append(("Bollinger Position", "PUT", 0.10))

            base_votes = [signal for (_, signal, _) in strategies if signal in {"CALL", "PUT"}]
            if base_direction in {"CALL", "PUT"}:
                main_signal = base_direction
            elif base_votes:
                main_signal = max(set(base_votes), key=base_votes.count)
            else:
                main_signal = "CALL"

            if self.strategy_flags.get("bollinger_rebound", True):
                try:
                    bb = BollingerBands(close=close_prices, window=20, window_dev=2)
                    upper = float(bb.bollinger_hband().iloc[-1])
                    lower = float(bb.bollinger_lband().iloc[-1])
                    last_close = float(close_prices.iloc[-1])
                    if last_close <= lower:
                        strategies.append(("Bollinger Rebound", "CALL", 0.20))
                    elif last_close >= upper:
                        strategies.append(("Bollinger Rebound", "PUT", 0.20))
                except Exception:
                    pass

            if self.strategy_flags.get("adx_trend", True):
                try:
                    adx = ADXIndicator(high_prices, low_prices, close_prices, window=14)
                    adx_val = float(adx.adx().iloc[-1])
                    if adx_val >= 25 and main_signal in {"CALL", "PUT"}:
                        strategies.append(("ADX Trend", main_signal, 0.15))
                except Exception:
                    pass

            if self.strategy_flags.get("volume_spike", True):
                try:
                    avg_volume = float(volumes.iloc[-10:].mean()) if len(volumes) >= 10 else float(volumes.mean())
                    if len(volumes) and volumes.iloc[-1] > avg_volume * 1.8 and main_signal in {"CALL", "PUT"}:
                        strategies.append(("Volume Spike", main_signal, 0.15))
                except Exception:
                    pass

            if self.strategy_flags.get("breakout", True):
                try:
                    prev_high = float(high_prices.iloc[-2])
                    prev_low = float(low_prices.iloc[-2])
                    last_close = float(close_prices.iloc[-1])
                    if last_close > prev_high:
                        strategies.append(("Breakout High", "CALL", 0.25))
                    elif last_close < prev_low:
                        strategies.append(("Breakout Low", "PUT", 0.25))
                except Exception:
                    pass

            if self.strategy_flags.get("momentum_candle", True):
                try:
                    body = abs(float(open_prices.iloc[-1]) - float(close_prices.iloc[-1]))
                    wick = abs(float(high_prices.iloc[-1]) - float(low_prices.iloc[-1]))
                    if body > wick * 0.70:
                        momentum_direction = "CALL" if float(close_prices.iloc[-1]) > float(open_prices.iloc[-1]) else "PUT"
                        strategies.append(("Momentum Candle", momentum_direction, 0.20))
                except Exception:
                    pass

            confidence = sum(weight for (_, _, weight) in strategies)
            confidence = min(confidence, 1.0)

            votes = [signal for (_, signal, _) in strategies if signal in {"CALL", "PUT"}]
            if votes:
                direction = max(set(votes), key=votes.count)
            else:
                direction = "NONE"

            analysis["confidence"] = confidence
            analysis["direction"] = direction

            memory_applied = False
            if self.strategy_flags.get("memory", True) and direction in {"CALL", "PUT"}:
                boosted_confidence, memory_applied = self.memory.apply_memory(
                    symbol,
                    float(analysis.get("rsi_value", 0.0)),
                    str(analysis.get("ema_trend", "flat")),
                    str(analysis.get("macd_signal", "NONE")),
                    pullback_flag,
                    confidence,
                    self.memory_boost,
                )
                if memory_applied:
                    self.logger.log(f"üß† Memory match: +{self.memory_boost:.2f} confidence boost")
                confidence = min(float(boosted_confidence), 1.0)

            analysis["confidence"] = confidence
            self.last_confidence = confidence

            strategy_name_map = {
                "rsi_direction": "RSI",
                "ema_trend": "EMA Trend",
                "macd_momentum": "MACD",
                "adx_trend": "ADX Trend",
                "volume_spike": "Volume Spike",
                "breakout": "Breakout",
                "momentum_candle": "Momentum Candle",
                "bollinger_position": "Bollinger Position",
                "bollinger_rebound": "Bollinger Rebound",
                "pullback_signal": "Pullback",
                "memory": "Memory IA",
            }

            self.logger.log(f"\n=== {symbol} ===")

            strategy_votes = 0
            active_strategies = 0

            for key, enabled in self.strategy_flags.items():
                if not enabled:
                    continue

                active_strategies += 1
                expected = strategy_name_map.get(key, key)

                match = next(((name, sig, w) for (name, sig, w) in strategies if expected in name), None)

                if match:
                    name, sig, w = match
                    strategy_votes += 1
                    self.logger.log(f" ‚úÖ {name:<22} ‚Üí {sig} (weight={w:.2f})")
                else:
                    self.logger.log(f" ‚ùå {expected:<22} ‚Üí no signal")

            self.logger.log(f"[{symbol}] Active strategies: {active_strategies} | Strategies with signal: {strategy_votes}")
            self.logger.log(f"[{symbol}] Confidence = {confidence:.2f}")
            self.logger.log("------------------------------------------------------------")

            self._notify_confidence(confidence, direction)

            if not BOT_ACTIVE:
                self.logger.log("‚è∏ Trading paused via Telegram.")
                return

            if confidence < 0.60:
                self.logger.log(f"[{symbol}] ‚ùå No trade ‚Üí Confidence too low ({confidence:.2f})")
                return

            if strategy_votes < 2:
                self.logger.log(f"[{symbol}] ‚ùå No trade ‚Üí Not enough confluence ({strategy_votes}/2 strategies)")
                return

            if direction not in {"CALL", "PUT"}:
                self.logger.log(f"[{symbol}] ‚ùå No trade ‚Üí Direction unavailable")
                return

            vote_count = len([s for (_, s, _) in strategies if s == direction])
            if vote_count < 2:
                self.logger.log(f"[{symbol}] ‚ùå No trade ‚Üí Not enough aligned votes ({vote_count}/2)")
                return

            candle_time = df.index[-1]
            last_attr = f"last_candle_{symbol}"
            if getattr(self, last_attr, None) != candle_time:
                setattr(self, last_attr, candle_time)
            else:
                self.logger.log(f"[{symbol}] ‚ÑπÔ∏è Trade already processed for this candle")
                return

            lot = self._select_lot_by_confidence()
            executed = self.execute_market_order(symbol, direction, lot)

            if executed:
                self._handle_market_order_success(symbol, direction, confidence, lot, analysis)
                self._notify_status("Operation executed")
        finally:
            self.cycle_lock.release()

    def execute_market_order(self, symbol: str, direction: str, lot: float) -> bool:
        info = mt5.symbol_info(symbol)
        if not info:
            self.logger.log(f"‚ö†Ô∏è Symbol not found: {symbol}")
            return False

        if not info.visible:
            mt5.symbol_select(symbol, True)

        volume = max(lot, info.volume_min)
        min_lot = getattr(info, "volume_min", volume)
        max_lot = getattr(info, "volume_max", volume)
        step = getattr(info, "volume_step", 0.0) or 0.0
        volume = max(min_lot, min(volume, max_lot))
        if step:
            volume = round(volume / step) * step

        tick = mt5.symbol_info_tick(symbol)
        if tick is None:
            self.logger.log(f"‚ö†Ô∏è No tick data for {symbol}")
            return False

        order_type = mt5.ORDER_TYPE_BUY if direction == "CALL" else mt5.ORDER_TYPE_SELL
        price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid

        filling_mode = getattr(info, "filling_mode", mt5.ORDER_FILLING_FOK)
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": volume,
            "type": order_type,
            "price": price,
            "magic": 777,
            "comment": "botaxi",
            "type_filling": filling_mode,
        }

        result = mt5.order_send(request)
        if result is None or getattr(result, "retcode", None) != mt5.TRADE_RETCODE_DONE:
            retcode = getattr(result, "retcode", "no response")
            self.logger.log(f"‚ùå Market order failed [{symbol}]: {retcode}")
            return False

        ticket = int(getattr(result, "position", 0) or getattr(result, "order", 0) or getattr(result, "deal", 0) or 0)
        self._last_ticket_id = ticket
        self.logger.log(f"‚úÖ ORDER EXECUTED [{symbol}] ‚Üí {direction} lot={volume:.2f} ticket={ticket}")

        entry_price = float(price)
        if ticket:
            position = None
            attempts = 0
            while attempts < 5 and position is None:
                positions = mt5.positions_get(ticket=ticket)
                if positions is not None and len(positions) > 0:
                    position = positions[0]
                    break
                time.sleep(0.3)
                attempts += 1
            if position is None:
                alt_positions = mt5.positions_get(symbol=symbol)
                if alt_positions is not None:
                    for pos in alt_positions:
                        if int(getattr(pos, "ticket", 0)) == ticket:
                            position = pos
                            break
            if position is not None:
                entry_price = float(getattr(position, "price_open", price))

        df = self._fetch_rates(symbol)
        atr_value = calc_atr(df) if df is not None and not df.empty else 0.0
        if df is None or df.empty:
            df = pd.DataFrame({
                "open": [price],
                "high": [price],
                "low": [price],
                "close": [price],
            })
        sl_price, tp_price = self._calc_sl_tp_prices(symbol, direction, entry_price, df, atr_value)

        self.open_positions[ticket] = {
            "symbol": symbol,
            "ticket": ticket,
            "entry": entry_price,
            "sl": sl_price,
            "tp": tp_price,
            "type": order_type,
            "time": datetime.now(),
            "lot": volume,
        }

        self.rescue_sl_tp_for_open_positions()
        self.update_gui_positions()

        return True

    def _handle_market_order_success(
        self,
        symbol: str,
        direction: str,
        confidence: float,
        lot: float,
        analysis: Dict[str, Any],
    ) -> None:
        info = mt5.symbol_info(symbol)
        actual_lot = max(lot, info.volume_min) if info else lot
        message = f"‚úÖ ORDER EXECUTED [{symbol}] ‚Üí {direction} lot={actual_lot:.2f}"
        self.send_telegram(message)
        event = self._build_trade_event(
            symbol=symbol,
            decision=direction,
            confidence=confidence,
            result="PENDING",
            pnl=0.0,
            notes="Market order",
        )
        self._notify_order(event)
        trade_result = self._evaluate_trade_result(symbol, direction)
        pnl_value = self._estimate_pnl(trade_result, lot)
        self.memory.record_trade(
            symbol,
            float(analysis.get("rsi_value", 0.0)),
            str(analysis.get("ema_trend", "flat")),
            str(analysis.get("macd_signal", "NONE")),
            bool(analysis.get("pullback", False)),
            confidence,
            trade_result,
        )
        result_event = self._build_trade_event(
            symbol=symbol,
            decision=direction,
            confidence=confidence,
            result=trade_result,
            pnl=pnl_value,
            notes="Result",
        )
        result_message = f"Result {trade_result} ‚Äî [{symbol}] {direction}"
        self.logger.log(result_message)
        self.send_telegram(result_message)
        self._notify_order(result_event)
        is_win = trade_result == "WIN"
        ticket_id = getattr(self, "_last_ticket_id", 0)
        send_message(
            f"Operacion: #{ticket_id} {symbol}\n"
            f"Resultado: {'WIN ‚úÖ' if is_win else 'LOSS ‚ùå'}\n"
            f"Precision Actual: {self.get_accuracy():.2f}%\n"
            f"Pnl: {pnl_value:+.2f} USD"
        )

    def execute_pending_order(
        self,
        symbol: str,
        direction: str,
        price: float,
        df: pd.DataFrame,
        atr_value: float,
        lot: float,
    ) -> bool:
        mt5.symbol_select(symbol, True)
        info = mt5.symbol_info(symbol)
        volume = max(lot, info.volume_min) if info else lot
        if not self.apply_sl_tp_on_pending:
            sl_price, tp_price = 0.0, 0.0
        else:
            sl_price, tp_price = self._calc_sl_tp_prices(symbol, direction, price, df, atr_value)
        # --- SL/TP MIN DISTANCE ENFORCEMENT (FOREX SAFE MODE: A) ---
        stops_level = info.trade_stops_level
        point = info.point
        min_distance = stops_level * point

        if direction == "CALL":
            if (price - sl_price) < min_distance:
                sl_price = price - (min_distance * 2)
            if (tp_price - price) < min_distance:
                tp_price = price + (min_distance * 2)
        else:
            if (sl_price - price) < min_distance:
                sl_price = price + (min_distance * 2)
            if (price - tp_price) < min_distance:
                tp_price = price - (min_distance * 2)
        # -------------------------------------------------------------

        order = {
            "action": mt5.TRADE_ACTION_PENDING,
            "symbol": symbol,
            "volume": volume,
            "type": mt5.ORDER_TYPE_BUY_LIMIT if direction == "CALL" else mt5.ORDER_TYPE_SELL_LIMIT,
            "price": price,
            "sl": sl_price,
            "tp": tp_price,
            "deviation": 10,
            "magic": 123456,
            "comment": "AXINEW-pending",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_RETURN,
        }
        result = mt5.order_send(order)
        if result is None or result.retcode not in (mt5.TRADE_RETCODE_DONE, mt5.TRADE_RETCODE_PLACED):
            self.logger.log(f"Pending order failed for {symbol}: {getattr(result, 'retcode', 'no response')}")
            return False
        message = f"üìå PENDING ORDER SET [{symbol}] {direction} @ {price:.5f} lot={volume:.2f}"
        self.logger.log(message)
        self.send_telegram(message)
        event = self._build_trade_event(
            symbol=symbol,
            decision=direction,
            confidence=self.last_confidence,
            result="PENDING",
            pnl=0.0,
            notes="Pending order",
        )
        self._notify_order(event)
        return True

    def _determine_pending_price(self, direction: str, last_price: float, atr_value: float) -> float:
        offset = max(atr_value * 0.5, last_price * 0.001)
        if direction == "CALL":
            return last_price - offset
        return last_price + offset

    def _select_lot_by_confidence(self) -> float:
        if self.last_confidence >= self.base_confidence:
            return round(self.lot_high, 2)
        return round(self.lot_low, 2)

    def _fetch_rates(self, symbol: str) -> Optional[pd.DataFrame]:
        rates = mt5.copy_rates_from_pos(symbol, self.timeframe, 0, self.history_bars)
        if rates is None:
            self.logger.log(f"No data returned for {symbol}.")
            return None
        df = pd.DataFrame(rates)
        if df.empty:
            self.logger.log(f"Empty dataframe for {symbol}.")
            return None
        df["time"] = pd.to_datetime(df["time"], unit="s")
        df.set_index("time", inplace=True)
        return df

    def _points_per_pip(self, symbol: str) -> float:
        info = mt5.symbol_info(symbol)
        if info and info.digits in (3, 5):
            return 10.0
        return 1.0

    def _calc_sl_tp_prices(
        self,
        symbol: str,
        direction: str,
        entry_price: float,
        df: pd.DataFrame,
        atr_value: float,
    ) -> Tuple[float, float]:
        info = mt5.symbol_info(symbol)
        point = info.point if info else 0.0001
        if self.sl_tp_mode == "Fixed pips":
            pip_points = self._points_per_pip(symbol)
            sl_delta = float(self.sl_value) * pip_points * point
            tp_delta = float(self.tp_value) * pip_points * point
        else:
            atr_used = atr_value if atr_value else calc_atr(df)
            sl_delta = float(self.sl_value) * atr_used
            tp_delta = float(self.tp_value) * atr_used
        if direction == "CALL":
            sl_price = entry_price - sl_delta
            tp_price = entry_price + tp_delta
        else:
            sl_price = entry_price + sl_delta
            tp_price = entry_price - tp_delta
        return float(sl_price), float(tp_price)

    def _evaluate_trade_result(self, symbol: str, direction: str) -> str:
        rates = mt5.copy_rates_from_pos(symbol, self.timeframe, 0, 3)
        if rates is None or len(rates) == 0:
            return "UNKNOWN"
        df = pd.DataFrame(rates)
        if len(df) < 2:
            return "UNKNOWN"
        last_close = float(df["close"].iloc[-1])
        prev_close = float(df["close"].iloc[-2])
        if direction == "CALL":
            return "WIN" if last_close >= prev_close else "LOSS"
        if direction == "PUT":
            return "WIN" if last_close <= prev_close else "LOSS"
        return "UNKNOWN"

    def _estimate_pnl(self, result: str, lot: float) -> float:
        if result == "WIN":
            return round(lot, 2)
        if result == "LOSS":
            return round(-lot, 2)
        return 0.0

    def _build_trade_event(
        self,
        symbol: str,
        decision: str,
        confidence: float,
        result: str,
        pnl: float,
        notes: str,
    ) -> Dict[str, Any]:
        timestamp = datetime.now().strftime("%H:%M:%S")
        return {
            "time": timestamp,
            "symbol": symbol,
            "decision": decision,
            "confidence": round(confidence, 2),
            "result": result,
            "pnl": pnl,
            "notes": notes,
        }

    def _update_stats(self, result: str, pnl: float) -> None:
        if result not in {"WIN", "LOSS"}:
            return
        self.stats["trades"] += 1
        if result == "WIN":
            self.stats["wins"] += 1
        else:
            self.stats["losses"] += 1
        self.stats["pnl"] = round(float(self.stats["pnl"]) + pnl, 2)
        self.total_operations = self.stats["trades"]
        self._notify_stats()

    def _notify_status(self, status: str) -> None:
        if self.status_callback:
            self.status_callback(status)

    def _notify_confidence(self, confidence: float, direction: str) -> None:
        if self.confidence_callback:
            self.confidence_callback(confidence, direction)

    def _notify_order(self, event: Dict[str, Any]) -> None:
        if self.order_callback:
            self.order_callback(event)

    def _notify_stats(self) -> None:
        if self.stats_callback:
            self.stats_callback(dict(self.stats))

    def send_telegram(self, message: str) -> None:
        telegram_cfg = self.config.get("telegram", {})
        if not telegram_cfg.get("enabled"):
            return
        token = telegram_cfg.get("token")
        chat_id = telegram_cfg.get("chat_id")
        if not token or not chat_id:
            return
        if requests is None:
            self.logger.log("Telegram notification skipped (requests not available).")
            return

        def _worker() -> None:
            try:
                url = f"https://api.telegram.org/bot{token}/sendMessage"
                requests.post(url, data={"chat_id": chat_id, "text": message}, timeout=5)
            except Exception as exc:  # pragma: no cover
                self.logger.log(f"Telegram send failed: {exc}")

        threading.Thread(target=_worker, daemon=True).start()

    def _resolve_timeframe(self, name: str):
        if hasattr(mt5, name):
            return getattr(mt5, name)
        return mt5.TIMEFRAME_M1
