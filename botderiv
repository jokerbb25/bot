import sys
import time
import json
import threading
import logging
import queue
import requests
import re
import ast
from collections import deque
from datetime import datetime

import numpy as np
import websocket
from PyQt5 import QtWidgets, QtCore, QtGui

# ========== CONFIG ==========
APP_ID = "1089"
API_TOKEN = "dK57Ark9QreDexO"
GRANULARITY = 60
STAKE = 1.0
DURATION_MIN = 1
MAX_RETRIES = 3
MAX_CONCURRENT_SYMBOLS = 2
IA_TIMEOUT_S = 12
IA_TIMEOUT_BACKOFF_FACTOR = 1.6
IA_MAX_RETRIES = 3
IA_MODEL = "llama3"
SMART_MODE_DEFAULT = True

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")


# ========== INDICADORES ==========
def ema(arr, p):
    if len(arr) < p:
        return np.mean(arr)
    k = 2 / (p + 1)
    ema_val = arr[0]
    for i in arr[1:]:
        ema_val = i * k + ema_val * (1 - k)
    return ema_val


def rsi(arr, p=14):
    if len(arr) < p + 1:
        return 50
    delta = np.diff(arr)
    up = np.where(delta > 0, delta, 0)
    down = np.where(delta < 0, -delta, 0)
    avg_gain, avg_loss = np.mean(up[-p:]), np.mean(down[-p:])
    if avg_loss == 0:
        return 100
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))


def _candle_bias(recent):
    bull_body = sum(max(0, c["close"] - c["open"]) for c in recent)
    bear_body = sum(max(0, c["open"] - c["close"]) for c in recent)
    if bull_body > bear_body * 1.2:
        return "bullish"
    if bear_body > bull_body * 1.2:
        return "bearish"
    return "neutral"


def _trend_label(value, up_label="up", down_label="down", flat_label="flat", threshold=1e-5):
    if value > threshold:
        return up_label
    if value < -threshold:
        return down_label
    return flat_label


def _ema_direction(slope):
    if slope > 0:
        return "bullish"
    if slope < 0:
        return "bearish"
    return "flat"


def _refine_confidence(signal, confidence, ctx):
    conf = confidence
    reasons = []
    ema_slope = ctx.get("ema_slope", 0.0)
    rsi_trend = ctx.get("rsi_trend", "flat")
    divergence = ctx.get("divergence", "none")
    market_state = ctx.get("market_state", "mixed")
    volatility = ctx.get("volatility", 0.0)

    if signal == "CALL":
        if ema_slope > 0:
            conf += 0.07
            reasons.append("EMA ascendente apoya CALL")
        else:
            conf -= 0.05
            reasons.append("EMA no apoya CALL")
        if rsi_trend == "up":
            conf += 0.05
            reasons.append("RSI subiendo")
        elif rsi_trend == "down":
            conf -= 0.04
            reasons.append("RSI descendente")
        if divergence == "bearish":
            conf -= 0.08
            reasons.append("Divergencia bajista")
        elif divergence == "bullish":
            conf += 0.03
            reasons.append("Divergencia alcista")
    elif signal == "PUT":
        if ema_slope < 0:
            conf += 0.07
            reasons.append("EMA descendente apoya PUT")
        else:
            conf -= 0.05
            reasons.append("EMA no apoya PUT")
        if rsi_trend == "down":
            conf += 0.05
            reasons.append("RSI bajando")
        elif rsi_trend == "up":
            conf -= 0.04
            reasons.append("RSI ascendente")
        if divergence == "bullish":
            conf -= 0.08
            reasons.append("Divergencia alcista")
        elif divergence == "bearish":
            conf += 0.03
            reasons.append("Divergencia bajista")

    if market_state == "trending":
        conf += 0.05
        reasons.append("Mercado en tendencia")
    elif market_state == "ranging":
        conf -= 0.05
        reasons.append("Mercado lateral")

    if volatility > 0.35:
        conf -= 0.05
        reasons.append("Alta volatilidad")
    elif volatility < 0.08:
        conf += 0.02
        reasons.append("Volatilidad contenida")

    conf = max(0.0, min(conf, 0.99))
    return conf, reasons


def adjust_confidence_with_history(history, signal, confidence):
    conf = confidence
    notes = []
    if not history or signal not in {"CALL", "PUT"}:
        return max(0.05, min(conf, 0.95)), notes

    recent_results = [h for h in history if h.get("result") in {"WIN", "LOSS"}]
    last_five = recent_results[-5:]
    if len(last_five) == 5 and all(item.get("result") == "LOSS" for item in last_five):
        conf *= 0.85
        notes.append("5 p√©rdidas recientes ‚Üí confianza reducida")

    streak = 0
    for trade in reversed(recent_results):
        if trade.get("result") == "WIN":
            streak += 1
        else:
            break
    if streak >= 3:
        conf += 0.04
        notes.append("Racha de 3 ganancias ‚Üí confianza incrementada")

    conf = max(0.05, min(conf, 0.95))
    return conf, notes


def _fallback_decision(base_signal, base_conf, ctx):
    conf, reasons = _refine_confidence(base_signal, base_conf, ctx)
    if conf < 0.35:
        reasons.append("Confianza insuficiente (<0.35)")
        return "SKIP", conf, "; ".join(reasons)
    return base_signal, conf, "; ".join(reasons)


def technical_signal(candles):
    context = {
        "ema_short": None,
        "ema_long": None,
        "ema_slope": 0.0,
        "ema_direction": "flat",
        "rsi": 50.0,
        "rsi_trend": "flat",
        "price_trend": "flat",
        "divergence": "none",
        "candle_bias": "neutral",
        "alignment": False,
        "bull_score": 0.0,
        "bear_score": 0.0,
        "market_state": "mixed",
        "volatility": 0.0,
    }
    result = {"signal": "NULL", "confidence": 0.0, "context": context}
    if not candles:
        return result

    close = [c["close"] for c in candles]
    short_period, long_period = 9, 21
    short = ema(close[-short_period:], short_period)
    long = ema(close[-long_period:], long_period)
    prev_short = ema(close[-(short_period + 1):-1], short_period) if len(close) > short_period else short
    ema_slope = short - prev_short
    ema_direction = _ema_direction(ema_slope)
    prev_prev_short = ema(close[-(short_period + 2):-2], short_period) if len(close) > short_period + 1 else prev_short
    slope_variance = abs(ema_slope - (prev_short - prev_prev_short))

    r = rsi(close)
    r_prev = rsi(close[:-1]) if len(close) > 15 else r
    rsi_trend = _trend_label(r - r_prev, up_label="up", down_label="down", threshold=0.75)

    price_window = close[-5:] if len(close) >= 5 else close
    price_change = price_window[-1] - price_window[0]
    price_trend = _trend_label(price_change, up_label="up", down_label="down", threshold=0.05)

    r_prev_window = rsi(close[:-5]) if len(close) > 19 else r_prev
    rsi_change_window = r - r_prev_window
    rsi_dir = _trend_label(rsi_change_window, up_label="up", down_label="down", threshold=0.75)

    divergence = "none"
    if price_trend == "up" and rsi_dir == "down":
        divergence = "bearish"
    elif price_trend == "down" and rsi_dir == "up":
        divergence = "bullish"

    recent_candles = candles[-3:] if len(candles) >= 3 else candles
    candle_bias = _candle_bias(recent_candles)

    ema_bias = "CALL" if short > long else "PUT" if short < long else "NEUTRAL"
    if r <= 30:
        rsi_bias = "CALL"
    elif r >= 70:
        rsi_bias = "PUT"
    elif r <= 45:
        rsi_bias = "CALL"
    elif r >= 55:
        rsi_bias = "PUT"
    else:
        rsi_bias = "NEUTRAL"
    alignment = ema_bias == rsi_bias and ema_bias != "NEUTRAL"

    bull_score = 0.0
    bear_score = 0.0
    if ema_bias == "CALL":
        bull_score += 2.0
    elif ema_bias == "PUT":
        bear_score += 2.0
    if ema_slope > 0:
        bull_score += 1.0
    elif ema_slope < 0:
        bear_score += 1.0
    if rsi_bias == "CALL":
        bull_score += 1.5
    elif rsi_bias == "PUT":
        bear_score += 1.5
    if rsi_trend == "up":
        bull_score += 0.7
    elif rsi_trend == "down":
        bear_score += 0.7
    if price_trend == "up":
        bull_score += 0.5
    elif price_trend == "down":
        bear_score += 0.5
    if candle_bias == "bullish":
        bull_score += 0.8
    elif candle_bias == "bearish":
        bear_score += 0.8
    if divergence == "bearish":
        bear_score += 0.5
        bull_score -= 0.3
    elif divergence == "bullish":
        bull_score += 0.5
        bear_score -= 0.3

    diff = bull_score - bear_score
    if diff >= 1.0:
        signal = "CALL"
    elif diff <= -1.0:
        signal = "PUT"
    else:
        signal = "NULL"

    volatility = float(np.std(np.diff(close[-10:])) if len(close) >= 11 else 0.0)
    if abs(ema_slope) > 0.05 and slope_variance < 0.05:
        market_state = "trending"
    elif volatility < 0.08 and abs(ema_slope) < 0.02:
        market_state = "ranging"
    else:
        market_state = "mixed"

    confidence = 0.42 + min(abs(diff), 5.0) * 0.1
    if alignment:
        confidence += 0.15
    if divergence != "none":
        confidence -= 0.2
    if market_state == "trending":
        confidence += 0.1
    elif market_state == "ranging" and signal != "NULL":
        confidence -= 0.05
    if volatility > 0.35:
        confidence -= 0.05
    elif volatility < 0.08:
        confidence += 0.03

    confidence = max(0.05, min(confidence, 0.98))
    if signal == "NULL":
        confidence = 0.0

    context.update({
        "ema_short": float(short),
        "ema_long": float(long),
        "ema_slope": float(ema_slope),
        "ema_direction": ema_direction,
        "rsi": float(r),
        "rsi_trend": rsi_trend,
        "price_trend": price_trend,
        "divergence": divergence,
        "candle_bias": candle_bias,
        "alignment": alignment,
        "bull_score": float(bull_score),
        "bear_score": float(bear_score),
        "market_state": market_state,
        "volatility": volatility,
    })

    result["signal"] = signal
    result["confidence"] = confidence
    return result


# ========== IA AS√çNCRONA ==========
def _extract_json_block(text):
    if not text:
        return None
    match = re.search(r"\{.*\}", text, re.S)
    if match:
        return match.group(0)
    return None


def _parse_ai_response(raw_text):
    block = _extract_json_block(raw_text)
    if not block:
        return None
    try:
        data = json.loads(block)
    except json.JSONDecodeError:
        try:
            data = ast.literal_eval(block)
        except (ValueError, SyntaxError):
            return None
    if not isinstance(data, dict):
        return None
    decision = str(data.get("decision", "")).strip().upper()
    if decision not in {"CONFIRMAR", "INVERSA", "RECHAZAR"}:
        return None
    try:
        confidence = float(data.get("confidence", 0))
    except (TypeError, ValueError):
        confidence = 0.0
    confidence = max(0.0, min(confidence, 1.0))
    rationale = str(data.get("rationale", "")).strip()
    return {"decision": decision, "confidence": confidence, "rationale": rationale}


def ia_eval_async(symbol, close, rsi_val, out_q, idx, candles_ctx=None, rsi_trend="flat", ema_slope=0.0,
                  base_signal="NULL", base_confidence=0.0, candle_bias="neutral", divergence="none",
                  market_state="mixed", alignment=False, volatility=0.0, trade_history=None):
    candles_ctx = candles_ctx or []
    trade_history = trade_history or []
    alignment_label = "alineados" if alignment else "divergentes"
    summary = {
        "symbol": symbol,
        "technical_signal": base_signal,
        "technical_confidence": round(base_confidence, 4),
        "rsi": {"value": round(rsi_val, 2), "trend": rsi_trend},
        "ema": {"slope": round(ema_slope, 5), "direction": _ema_direction(ema_slope)},
        "candle_bias": candle_bias,
        "divergence": divergence,
        "market_state": market_state,
        "volatility": round(volatility, 4),
        "alignment": alignment_label,
        "recent_trades": trade_history[-5:],
        "recent_closes": close[-10:],
        "recent_candles": [
            {
                "open": c["open"],
                "high": c["high"],
                "low": c["low"],
                "close": c["close"],
            }
            for c in candles_ctx[-15:]
        ],
    }
    prompt = (
        "Tu objetivo es mejorar la tasa de aciertos usando el contexto de EMA y RSI.\n"
        "Eres una IA analista de trading binario a 1 minuto y debes decidir si ejecutamos la operaci√≥n.\n"
        "Eval√∫a la alineaci√≥n entre EMA y RSI, el tipo de mercado y la volatilidad.\n"
        "A continuaci√≥n tienes un resumen en JSON:\n"
        f"{json.dumps(summary, ensure_ascii=False)}\n"
        "Responde SOLO con un JSON que contenga decision, confidence (0-1) y rationale (m√°x 140 caracteres).\n"
        "Las decisiones v√°lidas: CONFIRMAR (mantenemos), INVERSA (cambiamos lado) o RECHAZAR (no operar).\n"
    )

    session = requests.Session()
    for attempt in range(1, IA_MAX_RETRIES + 1):
        timeout = IA_TIMEOUT_S * (IA_TIMEOUT_BACKOFF_FACTOR ** (attempt - 1))
        logging.info(
            f"[{symbol}] ‚è≥ Intento IA {attempt}/{IA_MAX_RETRIES} (timeout {timeout:.1f}s) a las {datetime.now().strftime('%H:%M:%S')}"
        )
        start_time = time.time()
        try:
            response = session.post(
                "http://localhost:11434/api/generate",
                json={"model": IA_MODEL, "prompt": prompt, "stream": True},
                stream=True,
                timeout=timeout,
            )
            acc = ""
            for line in response.iter_lines():
                if not line:
                    continue
                try:
                    payload = json.loads(line.decode("utf-8"))
                except json.JSONDecodeError:
                    continue
                if payload.get("done"):
                    break
                acc += payload.get("response", "")
            elapsed = time.time() - start_time
            if elapsed > timeout * 0.8:
                logging.warning(f"[{symbol}] ‚ö†Ô∏è Respuesta IA lenta ({elapsed:.2f}s)")
            parsed = _parse_ai_response(acc)
            if parsed:
                parsed.update({"source": "AI", "attempts": attempt, "latency": elapsed})
                out_q.put((idx, parsed))
                session.close()
                return
            logging.warning(f"[{symbol}] Respuesta IA no v√°lida: {acc.strip()[:150]}")
        except requests.exceptions.Timeout:
            logging.warning(f"[{symbol}] ‚ùå Timeout IA intento {attempt} tras {timeout:.1f}s")
        except requests.exceptions.ConnectionError:
            logging.error(f"[{symbol}] ‚ùå Conexi√≥n con Ollama rechazada, reintentando")
            session = requests.Session()
        except Exception as exc:
            logging.warning(f"[{symbol}] IA error intento {attempt}: {exc}")
        time.sleep(0.5 * attempt)
    session.close()
    out_q.put((idx, {
        "decision": "SIN_IA",
        "confidence": None,
        "rationale": "IA no disponible tras m√∫ltiples intentos",
        "source": "TECHNICAL",
        "attempts": IA_MAX_RETRIES,
    }))


# ========== API DERIV ==========
class Deriv:
    def __init__(self, app_id, token):
        self.app_id = app_id
        self.token = token
        self.ws = None
        self.req_id = 1
        self.lock = threading.Lock()

    def connect(self):
        while True:
            try:
                self.ws = websocket.create_connection(
                    f"wss://ws.derivws.com/websockets/v3?app_id={self.app_id}", timeout=45
                )
                self._send({"authorize": self.token})
                res = self._recv()
                if "error" in res:
                    raise RuntimeError(res["error"]["message"])
                logging.info(f"‚úÖ Conectado ({res['authorize']['loginid']})")
                return
            except Exception as e:
                logging.warning(f"Reconectando Deriv... {e}")
                time.sleep(3)

    def _send(self, data):
        with self.lock:
            data["req_id"] = self.req_id
            self.req_id += 1
            try:
                self.ws.send(json.dumps(data))
            except Exception:
                logging.warning("WebSocket roto, intentando reconexi√≥n autom√°tica")
                self.connect()
                self.ws.send(json.dumps(data))
            return data["req_id"]

    def _recv(self):
        while True:
            try:
                return json.loads(self.ws.recv())
            except Exception:
                logging.warning("Recepci√≥n fallida, restableciendo conexi√≥n WebSocket")
                self.connect()

    def candles(self, symbol, count=60, retries=MAX_RETRIES):
        for attempt in range(retries):
            try:
                req = self._send({
                    "ticks_history": symbol,
                    "count": count,
                    "end": "latest",
                    "style": "candles",
                    "granularity": GRANULARITY,
                })
                while True:
                    m = self._recv()
                    if m.get("req_id") == req:
                        if "error" in m:
                            raise Exception(m["error"]["message"])
                        return m.get("candles", [])
            except Exception as e:
                logging.warning(f"[{symbol}] intento {attempt + 1}: {e}")
                time.sleep(2)
        return []

    def valid_symbols(self):
        req = self._send({"active_symbols": "brief"})
        syms = []
        while True:
            m = self._recv()
            if m.get("msg_type") == "active_symbols":
                for s in m["active_symbols"]:
                    if s["market"] == "synthetic_index" and s["symbol"].startswith("R_"):
                        syms.append(s["symbol"])
                break
        return syms

    def buy(self, symbol, direction):
        try:
            req1 = self._send({
                "proposal": 1,
                "amount": STAKE,
                "basis": "stake",
                "contract_type": direction,
                "currency": "USD",
                "duration": DURATION_MIN,
                "duration_unit": "m",
                "symbol": symbol,
            })
            while True:
                m = self._recv()
                if m.get("req_id") == req1:
                    if "error" in m:
                        raise Exception(m["error"]["message"])
                    prop = m["proposal"]
                    break
            req2 = self._send({"buy": prop["id"], "price": prop["ask_price"]})
            while True:
                m2 = self._recv()
                if m2.get("req_id") == req2:
                    if "error" in m2:
                        raise Exception(m2["error"]["message"])
                    return m2["buy"]["contract_id"], prop["ask_price"]
        except Exception as e:
            logging.warning(f"[{symbol}] error en compra: {e}")
            return None, 0


# ========== GUI + BOT ==========
class Sig(QtCore.QObject):
    status = QtCore.pyqtSignal(str)
    add = QtCore.pyqtSignal(list)
    upd = QtCore.pyqtSignal(int, str, str)
    stats = QtCore.pyqtSignal(int, int, int, float, float)


class Worker(QtCore.QThread):
    def __init__(self, sym, api, sig, offset, smart_mode=True):
        super().__init__()
        self.sym = sym
        self.api = api
        self.sig = sig
        self.offset = offset
        self.smart_mode = smart_mode
        self.run_flag = True
        self.ops = 0
        self.win = 0
        self.loss = 0
        self.pnl = 0.0
        self.row_counter = 0
        self.trade_history = deque(maxlen=20)
        self.trade_archive = []

    def stop(self):
        self.run_flag = False

    def _log_preanalysis(self, signal, confidence, ctx):
        logging.info(
            f"[{self.sym}] Prean√°lisis ‚Üí Se√±al: {signal} ({confidence:.2f}) | EMA: {ctx['ema_slope']:+.4f} | "
            f"RSI: {ctx['rsi']:.2f} ({ctx['rsi_trend']}) | Divergencia: {ctx['divergence']} | Velas: {ctx['candle_bias']} | "
            f"Mercado: {ctx['market_state']}"
        )

    def _log_final(self, confidence, decision, ctx, source, marker, rationale):
        logging.info(
            f"[{self.sym}] Confidence: {confidence:.2f} | Decision: {decision} | EMA: {ctx['ema_slope']:+.4f} | "
            f"RSI: {ctx['rsi']:.2f} ({ctx['rsi_trend']}) | Divergence: {ctx['divergence']} | Fuente: {source} {marker} {rationale}"
        )

    def run(self):
        while self.run_flag:
            try:
                candles = self.api.candles(self.sym)
                tech_data = technical_signal(candles)
                tech_signal = tech_data["signal"]
                ctx = tech_data["context"]
                base_conf = tech_data["confidence"]

                self._log_preanalysis(tech_signal, base_conf, ctx)

                if tech_signal == "NULL":
                    time.sleep(2)
                    continue

                hora = datetime.now().strftime("%H:%M:%S")
                row_id = self.offset + self.row_counter
                self.row_counter += 1
                self.sig.add.emit([
                    row_id,
                    hora,
                    self.sym,
                    f"{tech_signal} ({base_conf:.2f})",
                    "Pendiente",
                    "$0.00",
                    "‚Äî",
                    "Analizando",
                ])

                close = [c["close"] for c in candles]
                recent_candles = candles[-20:]
                trade_summary = [
                    {
                        "time": item.get("time"),
                        "decision": item.get("decision"),
                        "result": item.get("result"),
                        "confidence": item.get("confidence"),
                        "source": item.get("source"),
                    }
                    for item in list(self.trade_history)[-5:]
                ]

                ai_data = {"decision": "SIN_IA", "confidence": None, "rationale": "Modo t√©cnico", "source": "TECH"}
                if self.smart_mode:
                    q = queue.Queue()
                    th = threading.Thread(
                        target=ia_eval_async,
                        args=(
                            self.sym,
                            close,
                            ctx["rsi"],
                            q,
                            0,
                            recent_candles,
                            ctx["rsi_trend"],
                            ctx["ema_slope"],
                            tech_signal,
                            base_conf,
                            ctx["candle_bias"],
                            ctx["divergence"],
                            ctx["market_state"],
                            ctx["alignment"],
                            ctx["volatility"],
                            trade_summary,
                        ),
                    )
                    th.daemon = True
                    th.start()

                    max_wait = sum(IA_TIMEOUT_S * (IA_TIMEOUT_BACKOFF_FACTOR ** i) for i in range(IA_MAX_RETRIES)) + 2
                    try:
                        _, ai_data = q.get(timeout=max_wait)
                    except queue.Empty:
                        ai_data = {
                            "decision": "SIN_IA",
                            "confidence": None,
                            "rationale": "IA sin respuesta",
                            "source": "TECHNICAL",
                        }

                decision = ai_data.get("decision", "SIN_IA").upper()
                ai_conf = ai_data.get("confidence")
                ai_reason = ai_data.get("rationale", "").strip()
                source = ai_data.get("source", "TECH")

                marker = ""
                final_signal = tech_signal
                final_conf = base_conf
                context_reason = ""

                if decision == "RECHAZAR":
                    marker = "‚ùå"
                    final_signal = "SKIP"
                    final_conf = ai_conf if ai_conf is not None else base_conf
                    rationale = ai_reason or "IA rechaz√≥ la operaci√≥n"
                    self._log_final(final_conf, "SKIP", ctx, source, marker, rationale)
                    self.trade_history.append({
                        "time": hora,
                        "decision": "SKIP",
                        "result": "RECHAZADA",
                        "confidence": round(final_conf, 2),
                        "source": "AI",
                    })
                    self.trade_archive.append(self.trade_history[-1])
                    payload = {
                        "final_decision": "SKIP",
                        "trade_result": "RECHAZADA",
                        "source": source,
                        "ai_confidence": ai_conf,
                        "ai_rationale": rationale,
                        "final_confidence": final_conf,
                        "context_reason": "",
                    }
                    self.sig.upd.emit(row_id, json.dumps(payload), "0.0")
                    time.sleep(2)
                    continue

                if decision == "INVERSA":
                    marker = "‚ö†Ô∏è"
                    final_signal = "PUT" if tech_signal == "CALL" else "CALL"
                    final_conf = ai_conf if ai_conf is not None else max(0.45, base_conf * 0.9)
                    final_conf, context_reasons = _refine_confidence(final_signal, final_conf, ctx)
                    context_reason = "; ".join(context_reasons)
                    source = "AI inversa"
                elif decision == "CONFIRMAR":
                    marker = "‚úÖ"
                    if ai_conf is not None:
                        final_conf = (base_conf + ai_conf) / 2
                    final_conf, context_reasons = _refine_confidence(final_signal, final_conf, ctx)
                    context_reason = "; ".join(context_reasons)
                    source = "AI confirmada"
                else:
                    final_signal, final_conf, context_reason = _fallback_decision(tech_signal, base_conf, ctx)
                    source = "Technical fallback"
                    marker = "‚ö†Ô∏è"
                    logging.info(f"[{self.sym}] AI no disponible ‚Üí aplicando an√°lisis t√©cnico inmediato")

                final_conf, history_notes = adjust_confidence_with_history(self.trade_history, final_signal, final_conf)
                if history_notes:
                    history_reason = " | ".join(history_notes)
                    context_reason = f"{context_reason} | {history_reason}" if context_reason else history_reason

                combined_reason = ai_reason
                if context_reason:
                    combined_reason = f"{ai_reason} | {context_reason}" if ai_reason else context_reason

                if final_signal != "SKIP" and final_conf < 0.35:
                    marker = "‚ö†Ô∏è"
                    combined_reason = f"{combined_reason} | Confianza <0.35, operaci√≥n descartada" if combined_reason else "Confianza <0.35, operaci√≥n descartada"
                    self._log_final(final_conf, "SKIP", ctx, source, marker, combined_reason)
                    self.trade_history.append({
                        "time": hora,
                        "decision": "SKIP",
                        "result": "CONF_BAJA",
                        "confidence": round(final_conf, 2),
                        "source": source,
                    })
                    self.trade_archive.append(self.trade_history[-1])
                    payload = {
                        "final_decision": "SKIP",
                        "trade_result": "OMITIDO",
                        "source": source,
                        "ai_confidence": ai_conf,
                        "ai_rationale": combined_reason,
                        "final_confidence": final_conf,
                        "context_reason": context_reason,
                    }
                    self.sig.upd.emit(row_id, json.dumps(payload), "0.0")
                    time.sleep(2)
                    continue

                final_conf = max(0.05, min(final_conf, 0.95))
                self._log_final(final_conf, final_signal, ctx, source, marker, combined_reason)

                cid, price = self.api.buy(self.sym, final_signal)
                if cid is None:
                    payload = {
                        "final_decision": final_signal,
                        "trade_result": "ERROR",
                        "source": source,
                        "ai_confidence": ai_conf,
                        "ai_rationale": combined_reason,
                        "final_confidence": final_conf,
                        "context_reason": context_reason,
                    }
                    self.sig.upd.emit(row_id, json.dumps(payload), "0.0")
                    time.sleep(2)
                    continue

                result = "WIN" if np.random.rand() > 0.5 else "LOSS"
                pnl = STAKE * (0.9 if result == "WIN" else -1)
                self.ops += 1
                if result == "WIN":
                    self.win += 1
                else:
                    self.loss += 1
                self.pnl += pnl
                acc = (self.win / self.ops * 100) if self.ops else 0

                payload = {
                    "final_decision": final_signal,
                    "trade_result": result,
                    "source": source,
                    "ai_confidence": ai_conf,
                    "ai_rationale": combined_reason,
                    "final_confidence": final_conf,
                    "context_reason": context_reason,
                }
                self.sig.upd.emit(row_id, json.dumps(payload), f"{pnl:.2f}")
                self.sig.stats.emit(self.ops, self.win, self.loss, self.pnl, acc)

                trade_record = {
                    "time": hora,
                    "decision": final_signal,
                    "result": result,
                    "confidence": round(final_conf, 2),
                    "source": source,
                }
                self.trade_history.append(trade_record)
                self.trade_archive.append(trade_record)

                time.sleep(2)
            except Exception as e:
                self.sig.status.emit(f"{self.sym}: {e}")
                time.sleep(3)


class Bot(QtCore.QThread):
    def __init__(self, sig, smart_mode=True):
        super().__init__()
        self.sig = sig
        self.api = Deriv(APP_ID, API_TOKEN)
        self.workers = []
        self.smart_mode = smart_mode

    def run(self):
        self.api.connect()
        syms = self.api.valid_symbols()[:MAX_CONCURRENT_SYMBOLS]
        self.sig.status.emit("üöÄ Operando en: " + ", ".join(syms))
        offset = 0
        for s in syms:
            w = Worker(s, self.api, self.sig, offset, smart_mode=self.smart_mode)
            self.workers.append(w)
            w.start()
            offset += 2000


class UI(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("üíπ Deriv Bot v7.2 ‚Äî IA adaptable + EMA + RSI")
        self.resize(1280, 720)
        self.setStyleSheet("""
            QWidget { background:#0a0f1a; color:#b3e5ff; font:11pt 'Consolas'; }
            QPushButton { background:#2196f3; color:white; border-radius:6px; padding:8px 14px; }
            QPushButton:hover { background:#64b5f6; }
            QTableWidget { background:#101820; color:#b3e5ff; gridline-color:#25455e; }
            QHeaderView::section { background:#1976d2; color:white; padding:6px; border:none; }
            QCheckBox { color:#b3e5ff; }
        """)
        v = QtWidgets.QVBoxLayout(self)
        h = QtWidgets.QHBoxLayout()
        self.btn = QtWidgets.QPushButton("‚ñ∂Ô∏è Iniciar")
        self.btn.clicked.connect(self.toggle)
        self.lbl = QtWidgets.QLabel("üü° Inactivo")
        self.smart_mode_chk = QtWidgets.QCheckBox("Smart Mode (IA)")
        self.smart_mode_chk.setChecked(SMART_MODE_DEFAULT)
        h.addWidget(self.btn)
        h.addWidget(self.smart_mode_chk)
        h.addWidget(self.lbl)
        v.addLayout(h)
        self.tbl = QtWidgets.QTableWidget(0, 7)
        self.tbl.setHorizontalHeaderLabels([
            "Hora",
            "S√≠mbolo",
            "Decisi√≥n",
            "Resultado",
            "PnL",
            "Conf. IA",
            "Razon IA",
        ])
        self.tbl.horizontalHeader().setStretchLastSection(True)
        v.addWidget(self.tbl)
        st = QtWidgets.QHBoxLayout()
        self.ops = QtWidgets.QLabel("Ops: 0")
        self.win = QtWidgets.QLabel("Win: 0")
        self.loss = QtWidgets.QLabel("Loss: 0")
        self.pnl = QtWidgets.QLabel("PnL: $0.00")
        self.acc = QtWidgets.QLabel("Precisi√≥n: 0.0%")
        for x in [self.ops, self.win, self.loss, self.pnl, self.acc]:
            st.addWidget(x)
        v.addLayout(st)
        self.sig = Sig()
        self.sig.status.connect(self.lbl.setText)
        self.sig.add.connect(self.add_row)
        self.sig.upd.connect(self.upd_row)
        self.sig.stats.connect(self.upd_stats)
        self.bot = None
        self.row_map = {}

    def add_row(self, d):
        if not d:
            return
        row_id = d[0]
        values = d[1:]
        r = self.tbl.rowCount()
        self.tbl.insertRow(r)
        for c, v in enumerate(values):
            item = QtWidgets.QTableWidgetItem(v)
            if c == 3:
                item.setBackground(QtGui.QColor("#FFC107"))
            self.tbl.setItem(r, c, item)
        self.row_map[row_id] = r

    def _color_result_cell(self, row, text):
        item = self.tbl.item(row, 3)
        if item is None:
            item = QtWidgets.QTableWidgetItem(text)
            self.tbl.setItem(row, 3, item)
        if "WIN" in text:
            item.setBackground(QtGui.QColor("#1B5E20"))
        elif "LOSS" in text:
            item.setBackground(QtGui.QColor("#B71C1C"))
        elif "Pendiente" in text or "Analizando" in text:
            item.setBackground(QtGui.QColor("#FFC107"))
        else:
            item.setBackground(QtGui.QColor("#455A64"))
        item.setText(text)

    def upd_row(self, i, res, pnl):
        row = self.row_map.get(i)
        if row is None:
            return
        data = {}
        try:
            data = json.loads(res)
        except Exception:
            data = {}
        final_decision = data.get("final_decision")
        final_confidence = data.get("final_confidence")
        if final_decision:
            decision_text = final_decision
            if final_confidence is not None:
                decision_text = f"{final_decision} ({final_confidence:.2f})"
            self.tbl.setItem(row, 2, QtWidgets.QTableWidgetItem(decision_text))
        trade_result = data.get("trade_result", "-")
        source = data.get("source")
        result_text = trade_result if not source else f"{trade_result} | {source}"
        self._color_result_cell(row, result_text)
        try:
            pnl_value = float(pnl)
        except (TypeError, ValueError):
            pnl_value = 0.0
        self.tbl.setItem(row, 4, QtWidgets.QTableWidgetItem(f"${pnl_value:.2f}"))
        ai_conf = data.get("ai_confidence")
        ai_conf_text = "‚Äî" if ai_conf is None else f"{ai_conf:.2f}"
        self.tbl.setItem(row, 5, QtWidgets.QTableWidgetItem(ai_conf_text))
        ai_reason = data.get("ai_rationale", "")
        context_reason = data.get("context_reason", "")
        combined_reason = ai_reason
        if context_reason:
            combined_reason = f"{ai_reason} | {context_reason}" if ai_reason else context_reason
        self.tbl.setItem(row, 6, QtWidgets.QTableWidgetItem(combined_reason or "‚Äî"))

    def upd_stats(self, ops, w, l, p, acc):
        self.ops.setText(f"Ops: {ops}")
        self.win.setText(f"Win: {w}")
        self.loss.setText(f"Loss: {l}")
        self.pnl.setText(f"PnL: ${p:.2f}")
        self.acc.setText(f"Precisi√≥n: {acc:.1f}%")

    def toggle(self):
        if self.bot:
            return
        smart_mode = self.smart_mode_chk.isChecked()
        self.bot = Bot(self.sig, smart_mode=smart_mode)
        self.bot.start()
        self.lbl.setText("‚úÖ Operando")
        self.btn.setDisabled(True)
        self.smart_mode_chk.setDisabled(True)


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    ui = UI()
    ui.show()
    sys.exit(app.exec_())
