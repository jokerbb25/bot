import sys, time, json, threading, logging, queue, requests
import numpy as np
import websocket
from datetime import datetime
from PyQt5 import QtWidgets, QtCore, QtGui

# ========== CONFIG ==========
APP_ID = "1089"
API_TOKEN = "dK57Ark9QreDexO"
GRANULARITY = 60
STAKE = 1.0
DURATION_MIN = 1
MAX_RETRIES = 3
MAX_CONCURRENT_SYMBOLS = 2
IA_TIMEOUT_S = 10
IA_MODEL = "llama3"

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")

# ========== INDICADORES ==========
def ema(arr, p):
    if len(arr) < p: return np.mean(arr)
    k = 2 / (p + 1)
    ema_val = arr[0]
    for i in arr[1:]:
        ema_val = i * k + ema_val * (1 - k)
    return ema_val

def rsi(arr, p=14):
    if len(arr) < p + 1: return 50
    delta = np.diff(arr)
    up = np.where(delta > 0, delta, 0)
    down = np.where(delta < 0, -delta, 0)
    avg_gain, avg_loss = np.mean(up[-p:]), np.mean(down[-p:])
    if avg_loss == 0: return 100
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

def technical_signal(candles):
    if not candles: return "NULL"
    close = [c["close"] for c in candles]
    short, long = ema(close[-9:], 9), ema(close[-21:], 21)
    r = rsi(close)
    if short > long and r < 70: return "CALL"
    if short < long and r > 30: return "PUT"
    return "NULL"

# ========== IA AS√çNCRONA ==========
def ia_eval_async(close, rsi_val, out_q, idx):
    prompt = (
        "Eres una IA de trading binario 1m. Analiza tendencia y RSI.\n"
        f"Cierres: {close[-20:]}\nRSI(14): {rsi_val:.2f}\n"
        "Devuelve solo CONFIRMAR, RECHAZAR o INVERSA."
    )
    try:
        r = requests.post(
            "http://localhost:11434/api/generate",
            json={"model": IA_MODEL, "prompt": prompt, "stream": True},
            stream=True, timeout=IA_TIMEOUT_S,
        )
        acc = ""
        for line in r.iter_lines():
            if not line: continue
            j = json.loads(line.decode("utf-8"))
            acc += j.get("response", "")
        text = acc.upper()
        if "CONFIRMAR" in text: out_q.put((idx, "CONFIRMAR")); return
        if "INVERSA" in text: out_q.put((idx, "INVERSA")); return
        if "RECHAZAR" in text: out_q.put((idx, "RECHAZAR")); return
    except Exception as e:
        logging.warning(f"IA error: {e}")
    out_q.put((idx, "SIN_IA"))

# ========== API DERIV ==========
class Deriv:
    def __init__(self, app_id, token):
        self.app_id = app_id
        self.token = token
        self.ws = None
        self.req_id = 1
        self.lock = threading.Lock()

    def connect(self):
        while True:
            try:
                self.ws = websocket.create_connection(
                    f"wss://ws.derivws.com/websockets/v3?app_id={self.app_id}", timeout=45
                )
                self._send({"authorize": self.token})
                res = self._recv()
                if "error" in res:
                    raise RuntimeError(res["error"]["message"])
                logging.info(f"‚úÖ Conectado ({res['authorize']['loginid']})")
                return
            except Exception as e:
                logging.warning(f"Reconectando Deriv... {e}")
                time.sleep(3)

    def _send(self, data):
        with self.lock:
            data["req_id"] = self.req_id
            self.req_id += 1
            self.ws.send(json.dumps(data))
            return data["req_id"]

    def _recv(self):
        return json.loads(self.ws.recv())

    def candles(self, symbol, count=60, retries=MAX_RETRIES):
        for attempt in range(retries):
            try:
                req = self._send({
                    "ticks_history": symbol,
                    "count": count,
                    "end": "latest",
                    "style": "candles",
                    "granularity": GRANULARITY,
                })
                while True:
                    m = self._recv()
                    if m.get("req_id") == req:
                        if "error" in m:
                            raise Exception(m["error"]["message"])
                        return m.get("candles", [])
            except Exception as e:
                logging.warning(f"[{symbol}] intento {attempt+1}: {e}")
                time.sleep(2)
        return []

    def valid_symbols(self):
        req = self._send({"active_symbols": "brief"})
        syms = []
        while True:
            m = self._recv()
            if m.get("msg_type") == "active_symbols":
                for s in m["active_symbols"]:
                    if s["market"] == "synthetic_index" and s["symbol"].startswith("R_"):
                        syms.append(s["symbol"])
                break
        return syms

    def buy(self, symbol, direction):
        try:
            req1 = self._send({
                "proposal": 1,
                "amount": STAKE,
                "basis": "stake",
                "contract_type": direction,
                "currency": "USD",
                "duration": DURATION_MIN,
                "duration_unit": "m",
                "symbol": symbol,
            })
            while True:
                m = self._recv()
                if m.get("req_id") == req1:
                    if "error" in m: raise Exception(m["error"]["message"])
                    prop = m["proposal"]; break
            req2 = self._send({"buy": prop["id"], "price": prop["ask_price"]})
            while True:
                m2 = self._recv()
                if m2.get("req_id") == req2:
                    if "error" in m2: raise Exception(m2["error"]["message"])
                    return m2["buy"]["contract_id"], prop["ask_price"]
        except Exception as e:
            logging.warning(f"[{symbol}] error en compra: {e}")
            return None, 0

# ========== GUI + BOT ==========
class Sig(QtCore.QObject):
    status = QtCore.pyqtSignal(str)
    add = QtCore.pyqtSignal(list)
    upd = QtCore.pyqtSignal(int, str, str)
    stats = QtCore.pyqtSignal(int, int, int, float, float)

class Worker(QtCore.QThread):
    def __init__(self, sym, api, sig, offset):
        super().__init__()
        self.sym, self.api, self.sig, self.offset = sym, api, sig, offset
        self.run_flag = True
        self.ops = self.win = self.loss = 0
        self.pnl = 0.0

    def stop(self): self.run_flag = False

    def run(self):
        while self.run_flag:
            try:
                candles = self.api.candles(self.sym)
                tech = technical_signal(candles)
                if tech == "NULL": time.sleep(2); continue

                # se√±al base
                hora = datetime.now().strftime("%H:%M:%S")
                idx = self.offset + self.ops
                self.sig.add.emit([hora, self.sym, tech, "IA analizando...", "$0.00"])
                close = [c["close"] for c in candles]
                q = queue.Queue()
                th = threading.Thread(target=ia_eval_async, args=(close, rsi(close), q, 0))
                th.start()

                decision = "SIN_IA"
                t0 = time.time()
                while time.time() - t0 < IA_TIMEOUT_S:
                    try:
                        _, decision = q.get_nowait(); break
                    except queue.Empty: time.sleep(0.2)

                if decision == "RECHAZAR": continue
                if decision == "INVERSA": tech = "PUT" if tech == "CALL" else "CALL"

                cid, price = self.api.buy(self.sym, tech)
                if cid is None: continue
                result = "WIN" if np.random.rand() > 0.5 else "LOSS"  # simulado
                pnl = STAKE * (0.9 if result == "WIN" else -1)
                self.ops += 1
                if result == "WIN": self.win += 1
                else: self.loss += 1
                self.pnl += pnl
                acc = (self.win / self.ops * 100) if self.ops else 0
                self.sig.upd.emit(idx, result, f"${pnl:.2f}")
                self.sig.stats.emit(self.ops, self.win, self.loss, self.pnl, acc)
                time.sleep(2)
            except Exception as e:
                self.sig.status.emit(f"{self.sym}: {e}")
                time.sleep(3)

class Bot(QtCore.QThread):
    def __init__(self, sig):
        super().__init__()
        self.sig, self.api, self.workers = sig, Deriv(APP_ID, API_TOKEN), []

    def run(self):
        self.api.connect()
        syms = self.api.valid_symbols()[:MAX_CONCURRENT_SYMBOLS]
        self.sig.status.emit("üöÄ Operando en: " + ", ".join(syms))
        offset = 0
        for s in syms:
            w = Worker(s, self.api, self.sig, offset)
            self.workers.append(w)
            w.start()
            offset += 2000

class UI(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("üíπ Deriv Bot v7.1 ‚Äî IA completa + EMA + RSI + Reconexi√≥n")
        self.resize(1280, 720)
        self.setStyleSheet("""
            QWidget { background:#0a0f1a; color:#b3e5ff; font:11pt 'Consolas'; }
            QPushButton { background:#2196f3; color:white; border-radius:6px; padding:8px 14px; }
            QPushButton:hover { background:#64b5f6; }
            QTableWidget { background:#101820; color:#b3e5ff; gridline-color:#25455e; }
            QHeaderView::section { background:#1976d2; color:white; padding:6px; border:none; }
        """)
        v = QtWidgets.QVBoxLayout(self)
        h = QtWidgets.QHBoxLayout()
        self.btn = QtWidgets.QPushButton("‚ñ∂Ô∏è Iniciar")
        self.btn.clicked.connect(self.toggle)
        self.lbl = QtWidgets.QLabel("üü° Inactivo")
        h.addWidget(self.btn); h.addWidget(self.lbl); v.addLayout(h)
        self.tbl = QtWidgets.QTableWidget(0,5)
        self.tbl.setHorizontalHeaderLabels(["Hora","S√≠mbolo","Se√±al","Resultado","PnL"])
        self.tbl.horizontalHeader().setStretchLastSection(True)
        v.addWidget(self.tbl)
        st = QtWidgets.QHBoxLayout()
        self.ops=QtWidgets.QLabel("Ops: 0"); self.win=QtWidgets.QLabel("Win: 0")
        self.loss=QtWidgets.QLabel("Loss: 0"); self.pnl=QtWidgets.QLabel("PnL: $0.00")
        self.acc=QtWidgets.QLabel("Precisi√≥n: 0.0%")
        for x in [self.ops,self.win,self.loss,self.pnl,self.acc]: st.addWidget(x)
        v.addLayout(st)
        self.sig = Sig()
        self.sig.status.connect(self.lbl.setText)
        self.sig.add.connect(self.add_row)
        self.sig.upd.connect(self.upd_row)
        self.sig.stats.connect(self.upd_stats)
        self.bot=None

    def add_row(self, d):
        r=self.tbl.rowCount(); self.tbl.insertRow(r)
        for c,v in enumerate(d): self.tbl.setItem(r,c,QtWidgets.QTableWidgetItem(v))
    def upd_row(self,i,res,pnl):
        if i<self.tbl.rowCount():
            self.tbl.setItem(i,3,QtWidgets.QTableWidgetItem(res))
            self.tbl.setItem(i,4,QtWidgets.QTableWidgetItem(pnl))
    def upd_stats(self,ops,w,l,p,acc):
        self.ops.setText(f"Ops: {ops}"); self.win.setText(f"Win: {w}")
        self.loss.setText(f"Loss: {l}"); self.pnl.setText(f"PnL: ${p:.2f}")
        self.acc.setText(f"Precisi√≥n: {acc:.1f}%")
    def toggle(self):
        if self.bot: return
        self.bot=Bot(self.sig); self.bot.start()
        self.lbl.setText("‚úÖ Operando"); self.btn.setDisabled(True)

if __name__=="__main__":
    app=QtWidgets.QApplication(sys.argv)
    ui=UI(); ui.show()
    sys.exit(app.exec_())

