import sys
import time
import json
import threading
import logging
import queue
import requests
from collections import deque
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import websocket
from PyQt5 import QtWidgets, QtCore, QtGui

# =====================================
# CONFIGURACIÓN GENERAL
# =====================================
APP_ID = "1089"
API_TOKEN = "dK57Ark9QreDexO"
GRANULARITY = 60
STAKE = 1.0
DURATION_MIN = 1
MAX_RETRIES = 3
MAX_CONCURRENT_SYMBOLS = 2
IA_TIMEOUT_S = 15
IA_TIMEOUT_INCREMENT = 8
IA_MAX_RETRIES = 2
IA_MODEL = "llama3:8b"
SMART_MODE_DEFAULT = True
OLLAMA_HEALTH_TIMEOUT = 3

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")

# Lock global para garantizar peticiones IA secuenciales
ia_lock = threading.Lock()

# =====================================
# FUNCIONES DE INDICADORES
# =====================================
def ema(arr: List[float], period: int) -> float:
    if not arr:
        return 0.0
    if len(arr) < period:
        return float(np.mean(arr))
    k = 2 / (period + 1)
    ema_val = arr[0]
    for price in arr[1:]:
        ema_val = price * k + ema_val * (1 - k)
    return float(ema_val)


def rsi(arr: List[float], period: int = 14) -> float:
    if len(arr) < period + 1:
        return 50.0
    delta = np.diff(arr)
    up = np.where(delta > 0, delta, 0)
    down = np.where(delta < 0, -delta, 0)
    avg_gain = np.mean(up[-period:])
    avg_loss = np.mean(down[-period:])
    if avg_loss == 0:
        return 100.0
    rs = avg_gain / avg_loss
    return float(100 - (100 / (1 + rs)))


def _candle_bias(recent: List[Dict[str, float]]) -> str:
    bull_body = sum(max(0.0, candle["close"] - candle["open"]) for candle in recent)
    bear_body = sum(max(0.0, candle["open"] - candle["close"]) for candle in recent)
    if bull_body > bear_body * 1.2:
        return "bullish"
    if bear_body > bull_body * 1.2:
        return "bearish"
    return "neutral"


def _trend_label(value: float, up_label: str = "up", down_label: str = "down", flat_label: str = "flat", threshold: float = 1e-5) -> str:
    if value > threshold:
        return up_label
    if value < -threshold:
        return down_label
    return flat_label


def _ema_direction(slope: float) -> str:
    if slope > 0:
        return "bullish"
    if slope < 0:
        return "bearish"
    return "flat"


# =====================================
# AJUSTE DE CONFIANZA
# =====================================
def _refine_confidence(signal: str, confidence: float, ctx: Dict[str, Any]) -> Tuple[float, List[str]]:
    conf = confidence
    notes: List[str] = []
    ema_slope = ctx.get("ema_slope", 0.0)
    rsi_trend = ctx.get("rsi_trend", "flat")
    divergence = ctx.get("divergence", "none")
    market_state = ctx.get("market_state", "mixed")
    volatility = ctx.get("volatility", 0.0)

    if signal == "CALL":
        if ema_slope > 0:
            conf += 0.07
            notes.append("EMA ascendente")
        else:
            conf -= 0.05
            notes.append("EMA no apoya CALL")
        if rsi_trend == "up":
            conf += 0.05
            notes.append("RSI subiendo")
        elif rsi_trend == "down":
            conf -= 0.04
            notes.append("RSI descendente")
        if divergence == "bearish":
            conf -= 0.2
            notes.append("Divergencia bajista")
    elif signal == "PUT":
        if ema_slope < 0:
            conf += 0.07
            notes.append("EMA descendente")
        else:
            conf -= 0.05
            notes.append("EMA no apoya PUT")
        if rsi_trend == "down":
            conf += 0.05
            notes.append("RSI bajando")
        elif rsi_trend == "up":
            conf -= 0.04
            notes.append("RSI ascendiendo")
        if divergence == "bullish":
            conf -= 0.2
            notes.append("Divergencia alcista")

    if market_state == "trending":
        conf += 0.05
        notes.append("Mercado tendencial")
    elif market_state == "ranging":
        conf -= 0.05
        notes.append("Mercado lateral")

    if volatility > 0.35:
        conf -= 0.05
        notes.append("Volatilidad elevada")
    elif volatility < 0.08:
        conf += 0.02
        notes.append("Volatilidad contenida")

    conf = max(0.05, min(conf, 0.99))
    return conf, notes


def adjust_confidence_with_history(symbol: str, confidence: float, history: deque) -> Tuple[float, List[str]]:
    notes: List[str] = []
    if not history:
        return max(0.05, min(confidence, 0.95)), notes

    recent = [item for item in history if item.get("result") in {"WIN", "LOSS"}]
    last_five = recent[-5:]
    if len(last_five) == 5 and all(item.get("result") == "LOSS" for item in last_five):
        new_conf = max(0.05, confidence * 0.85)
        notes.append("⬇️ Reducción tras 5 pérdidas")
        logging.info(f"[{symbol}] ⬇️ Reducción de confianza por 5 pérdidas recientes")
        confidence = new_conf
    else:
        streak = 0
        for trade in reversed(recent):
            if trade.get("result") == "WIN":
                streak += 1
            else:
                break
        if streak >= 3:
            new_conf = min(0.95, confidence * 1.10)
            notes.append("⬆️ Incremento tras racha ganadora")
            logging.info(f"[{symbol}] ⬆️ Incremento de confianza por {streak} ganancias consecutivas")
            confidence = new_conf

    confidence = max(0.05, min(confidence, 0.95))
    return confidence, notes


def _fallback_decision(symbol: str, signal: str, confidence: float, ctx: Dict[str, Any]) -> Tuple[str, float, str]:
    refined, reasons = _refine_confidence(signal, confidence, ctx)
    details = "; ".join(reasons)
    if refined < 0.35:
        logging.info(f"[{symbol}] ⚠️ Confianza {refined:.2f} < 0.35 → operación omitida")
        return "SKIP", refined, details
    logging.info(f"[{symbol}] ⚙️ Fallback técnico usado (confianza {refined:.2f})")
    return signal, refined, details


# =====================================
# SEÑAL TÉCNICA
# =====================================
def technical_signal(candles: List[Dict[str, float]]) -> Dict[str, Any]:
    context = {
        "ema_short": None,
        "ema_long": None,
        "ema_slope": 0.0,
        "ema_direction": "flat",
        "rsi": 50.0,
        "rsi_trend": "flat",
        "price_trend": "flat",
        "divergence": "none",
        "candle_bias": "neutral",
        "alignment": False,
        "bull_score": 0.0,
        "bear_score": 0.0,
        "market_state": "mixed",
        "volatility": 0.0,
    }
    result = {"signal": "NULL", "confidence": 0.0, "context": context}
    if not candles:
        return result

    close = [candle["close"] for candle in candles]
    short_period, long_period = 9, 21
    short = ema(close[-short_period:], short_period)
    long = ema(close[-long_period:], long_period)
    prev_short = ema(close[-(short_period + 1):-1], short_period) if len(close) > short_period else short
    ema_slope = short - prev_short
    ema_direction = _ema_direction(ema_slope)
    prev_prev_short = ema(close[-(short_period + 2):-2], short_period) if len(close) > short_period + 1 else prev_short
    slope_variance = abs(ema_slope - (prev_short - prev_prev_short))

    r = rsi(close)
    r_prev = rsi(close[:-1]) if len(close) > 15 else r
    rsi_trend = _trend_label(r - r_prev, up_label="up", down_label="down", threshold=0.75)

    price_window = close[-5:] if len(close) >= 5 else close
    price_change = price_window[-1] - price_window[0] if price_window else 0.0
    price_trend = _trend_label(price_change, up_label="up", down_label="down", threshold=0.05)

    r_prev_window = rsi(close[:-5]) if len(close) > 19 else r_prev
    rsi_change_window = r - r_prev_window
    rsi_dir = _trend_label(rsi_change_window, up_label="up", down_label="down", threshold=0.75)

    divergence = "none"
    if price_trend == "up" and rsi_dir == "down":
        divergence = "bearish"
    elif price_trend == "down" and rsi_dir == "up":
        divergence = "bullish"

    recent_candles = candles[-3:] if len(candles) >= 3 else candles
    candle_bias = _candle_bias(recent_candles)

    ema_bias = "CALL" if short > long else "PUT" if short < long else "NEUTRAL"
    if r <= 30:
        rsi_bias = "CALL"
    elif r >= 70:
        rsi_bias = "PUT"
    elif r <= 45:
        rsi_bias = "CALL"
    elif r >= 55:
        rsi_bias = "PUT"
    else:
        rsi_bias = "NEUTRAL"
    alignment = ema_bias == rsi_bias and ema_bias != "NEUTRAL"

    bull_score = 0.0
    bear_score = 0.0
    if ema_bias == "CALL":
        bull_score += 2.0
    elif ema_bias == "PUT":
        bear_score += 2.0
    if ema_slope > 0:
        bull_score += 1.0
    elif ema_slope < 0:
        bear_score += 1.0
    if rsi_bias == "CALL":
        bull_score += 1.5
    elif rsi_bias == "PUT":
        bear_score += 1.5
    if rsi_trend == "up":
        bull_score += 0.7
    elif rsi_trend == "down":
        bear_score += 0.7
    if price_trend == "up":
        bull_score += 0.5
    elif price_trend == "down":
        bear_score += 0.5
    if candle_bias == "bullish":
        bull_score += 0.8
    elif candle_bias == "bearish":
        bear_score += 0.8
    if divergence == "bearish":
        bear_score += 0.5
        bull_score -= 0.3
    elif divergence == "bullish":
        bull_score += 0.5
        bear_score -= 0.3

    diff = bull_score - bear_score
    if diff >= 1.0:
        signal = "CALL"
    elif diff <= -1.0:
        signal = "PUT"
    else:
        signal = "NULL"

    volatility = float(np.std(np.diff(close[-10:])) if len(close) >= 11 else 0.0)
    if abs(ema_slope) > 0.05 and slope_variance < 0.05:
        market_state = "trending"
    elif volatility < 0.08 and abs(ema_slope) < 0.02:
        market_state = "ranging"
    else:
        market_state = "mixed"

    confidence = 0.42 + min(abs(diff), 5.0) * 0.1
    if alignment:
        confidence += 0.15
    if divergence != "none":
        confidence -= 0.2
    if market_state == "trending":
        confidence += 0.1
    elif market_state == "ranging" and signal != "NULL":
        confidence -= 0.05
    if volatility > 0.35:
        confidence -= 0.05
    elif volatility < 0.08:
        confidence += 0.03

    confidence = max(0.05, min(confidence, 0.98))
    if signal == "NULL":
        confidence = 0.0

    context.update({
        "ema_short": float(short),
        "ema_long": float(long),
        "ema_slope": float(ema_slope),
        "ema_direction": ema_direction,
        "rsi": float(r),
        "rsi_trend": rsi_trend,
        "price_trend": price_trend,
        "divergence": divergence,
        "candle_bias": candle_bias,
        "alignment": alignment,
        "bull_score": float(bull_score),
        "bear_score": float(bear_score),
        "market_state": market_state,
        "volatility": volatility,
    })

    result["signal"] = signal
    result["confidence"] = confidence
    return result


# =====================================
# UTILIDADES IA
# =====================================
def _extract_json(text: str) -> Optional[Dict[str, Any]]:
    if not text:
        return None
    start = text.find("{")
    end = text.rfind("}")
    if start == -1 or end == -1 or end <= start:
        return None
    snippet = text[start:end + 1]
    try:
        return json.loads(snippet)
    except json.JSONDecodeError:
        return None


def _parse_ai_response(raw_text: str) -> Optional[Dict[str, Any]]:
    data = _extract_json(raw_text)
    if not data:
        return None
    decision = str(data.get("decision", "")).strip().upper()
    if decision not in {"CONFIRMAR", "INVERSA", "RECHAZAR"}:
        return None
    try:
        confidence = float(data.get("confidence", 0.0))
    except (TypeError, ValueError):
        confidence = 0.0
    confidence = max(0.0, min(confidence, 1.0))
    rationale = str(data.get("rationale", "")).strip()
    return {"decision": decision, "confidence": confidence, "rationale": rationale}


def check_ollama_online() -> bool:
    try:
        requests.get("http://localhost:11434", timeout=OLLAMA_HEALTH_TIMEOUT)
        return True
    except Exception:
        return False


def ia_eval(symbol: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    summary = json.dumps(payload, ensure_ascii=False)
    prompt = (
        "You are an AI binary trading analyst. Decide whether to CONFIRM, INVERT, or REJECT the proposed signal using EMA + RSI context. Respond ONLY in JSON.\n"
        f"Summary: {summary}\n"
        "Return keys: decision, confidence, rationale."
    )

    with ia_lock:
        session = requests.Session()
        base_timeout = IA_TIMEOUT_S
        for attempt in range(1, IA_MAX_RETRIES + 1):
            timeout = base_timeout + IA_TIMEOUT_INCREMENT * (attempt - 1)
            logging.info(f"[{symbol}] ⏳ Intento IA {attempt}/{IA_MAX_RETRIES} (timeout {timeout}s)")
            start = time.time()
            try:
                response = session.post(
                    "http://localhost:11434/api/generate",
                    json={"model": IA_MODEL, "prompt": prompt, "stream": True},
                    stream=True,
                    timeout=timeout,
                )
                collected = ""
                for line in response.iter_lines():
                    if not line:
                        continue
                    try:
                        chunk = json.loads(line.decode("utf-8"))
                    except json.JSONDecodeError:
                        continue
                    if chunk.get("done"):
                        break
                    collected += chunk.get("response", "")
                elapsed = time.time() - start
                parsed = _parse_ai_response(collected)
                if parsed:
                    logging.info(
                        f"[{symbol}] ✅ IA decision: {parsed['decision']} (confidence {parsed['confidence']:.2f}) en {elapsed:.2f}s"
                    )
                    parsed["source"] = "AI"
                    return parsed
                logging.warning(f"[{symbol}] Respuesta IA inválida, reintento")
            except Exception as exc:
                logging.warning(f"[{symbol}] Error IA intento {attempt}: {exc}")
            time.sleep(1)
    logging.warning(f"[{symbol}] ⚠️ IA unavailable — using technical fallback")
    return {"decision": "SIN_IA", "confidence": None, "rationale": "AI fallback"}


# =====================================
# API DERIV
# =====================================
class Deriv:
    def __init__(self, app_id: str, token: str) -> None:
        self.app_id = app_id
        self.token = token
        self.ws: Optional[websocket.WebSocket] = None
        self.req_id = 1
        self.lock = threading.Lock()

    def connect(self) -> None:
        while True:
            try:
                self.ws = websocket.create_connection(
                    f"wss://ws.derivws.com/websockets/v3?app_id={self.app_id}", timeout=45
                )
                self._send({"authorize": self.token})
                res = self._recv()
                if "error" in res:
                    raise RuntimeError(res["error"]["message"])
                logging.info(f"✅ Conectado a Deriv ({res['authorize']['loginid']})")
                return
            except Exception as exc:
                logging.warning(f"Reconectando Deriv... {exc}")
                time.sleep(3)

    def _send(self, data: Dict[str, Any]) -> int:
        with self.lock:
            data["req_id"] = self.req_id
            self.req_id += 1
            if self.ws is None:
                raise RuntimeError("WebSocket no inicializado")
            self.ws.send(json.dumps(data))
            return data["req_id"]

    def _recv(self) -> Dict[str, Any]:
        if self.ws is None:
            raise RuntimeError("WebSocket no inicializado")
        raw = self.ws.recv()
        return json.loads(raw)

    def candles(self, symbol: str, count: int = 60, retries: int = MAX_RETRIES) -> List[Dict[str, Any]]:
        for attempt in range(retries):
            try:
                req = self._send({
                    "ticks_history": symbol,
                    "count": count,
                    "end": "latest",
                    "style": "candles",
                    "granularity": GRANULARITY,
                })
                while True:
                    message = self._recv()
                    if message.get("req_id") == req:
                        if "error" in message:
                            raise RuntimeError(message["error"]["message"])
                        return message.get("candles", [])
            except Exception as exc:
                logging.warning(f"[{symbol}] Error al obtener velas (intento {attempt + 1}): {exc}")
                time.sleep(2)
                self.connect()
        return []

    def valid_symbols(self) -> List[str]:
        req = self._send({"active_symbols": "brief"})
        symbols: List[str] = []
        while True:
            message = self._recv()
            if message.get("req_id") == req and message.get("msg_type") == "active_symbols":
                for item in message.get("active_symbols", []):
                    if item.get("market") == "synthetic_index" and item.get("symbol", "").startswith("R_"):
                        symbols.append(item["symbol"])
                break
        return symbols

    def buy(self, symbol: str, direction: str) -> Tuple[Optional[int], float]:
        try:
            req_proposal = self._send({
                "proposal": 1,
                "amount": STAKE,
                "basis": "stake",
                "contract_type": direction,
                "currency": "USD",
                "duration": DURATION_MIN,
                "duration_unit": "m",
                "symbol": symbol,
            })
            while True:
                message = self._recv()
                if message.get("req_id") == req_proposal:
                    if "error" in message:
                        raise RuntimeError(message["error"]["message"])
                    proposal = message["proposal"]
                    break
            req_buy = self._send({"buy": proposal["id"], "price": proposal["ask_price"]})
            while True:
                response = self._recv()
                if response.get("req_id") == req_buy:
                    if "error" in response:
                        raise RuntimeError(response["error"]["message"])
                    return response["buy"]["contract_id"], proposal["ask_price"]
        except Exception as exc:
            logging.warning(f"[{symbol}] Error en compra: {exc}")
            self.connect()
            return None, 0.0


# =====================================
# SEÑALES Y WORKER
# =====================================
class Sig(QtCore.QObject):
    status = QtCore.pyqtSignal(str)
    ai_status = QtCore.pyqtSignal(str)
    add = QtCore.pyqtSignal(list)
    upd = QtCore.pyqtSignal(int, str, str)
    stats = QtCore.pyqtSignal(int, int, int, float, float)


class Worker(QtCore.QThread):
    def __init__(self, symbol: str, api: Deriv, sig: Sig, offset: int, smart_mode: bool) -> None:
        super().__init__()
        self.symbol = symbol
        self.api = api
        self.sig = sig
        self.offset = offset
        self.smart_mode = smart_mode
        self.run_flag = True
        self.ops = 0
        self.win = 0
        self.loss = 0
        self.pnl = 0.0
        self.row_counter = 0
        self.trade_history: deque = deque(maxlen=20)

    def stop(self) -> None:
        self.run_flag = False

    def _log_preanalysis(self, signal: str, confidence: float, ctx: Dict[str, Any]) -> None:
        logging.info(
            f"[{self.symbol}] Preanálisis → Señal: {signal} ({confidence:.2f}) | EMA: {ctx['ema_slope']:+.4f} | RSI: {ctx['rsi']:.2f} ({ctx['rsi_trend']}) | Divergencia: {ctx['divergence']}"
        )

    def _build_ai_payload(self, ctx: Dict[str, Any], signal: str, confidence: float, closes: List[float]) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "technical_signal": signal,
            "technical_confidence": round(confidence, 4),
            "rsi": {"value": round(ctx["rsi"], 2), "trend": ctx["rsi_trend"]},
            "ema": {"slope": round(ctx["ema_slope"], 5), "direction": _ema_direction(ctx["ema_slope"])},
            "candle_bias": ctx["candle_bias"],
            "divergence": ctx["divergence"],
            "market_state": ctx["market_state"],
            "volatility": round(ctx["volatility"], 4),
            "alignment": ctx["alignment"],
            "recent_trades": list(self.trade_history)[-5:],
            "recent_closes": closes[-15:],
        }

    def run(self) -> None:
        while self.run_flag:
            try:
                candles = self.api.candles(self.symbol)
                tech = technical_signal(candles)
                signal = tech["signal"]
                confidence = tech["confidence"]
                ctx = tech["context"]

                self._log_preanalysis(signal, confidence, ctx)

                if signal == "NULL":
                    time.sleep(2)
                    continue

                timestamp = datetime.now().strftime("%H:%M:%S")
                row_id = self.offset + self.row_counter
                self.row_counter += 1
                self.sig.add.emit([
                    row_id,
                    timestamp,
                    self.symbol,
                    f"{signal} ({confidence:.2f})",
                    "Pendiente",
                    "$0.00",
                    "—",
                    "Analizando",
                ])

                closes = [candle["close"] for candle in candles]
                ai_info = {"decision": "SIN_IA", "confidence": None, "rationale": "AI omitida", "source": "TECH"}

                if self.smart_mode:
                    if check_ollama_online():
                        self.sig.ai_status.emit("🧠 AI Active")
                        payload = self._build_ai_payload(ctx, signal, confidence, closes)
                        ai_info = ia_eval(self.symbol, payload)
                    else:
                        logging.warning(f"[{self.symbol}] Ollama offline — skipping IA")
                        self.sig.ai_status.emit("🚫 AI Offline")
                else:
                    self.sig.ai_status.emit("⚙️ Modo técnico")

                decision = ai_info.get("decision", "SIN_IA")
                ai_conf = ai_info.get("confidence")
                ai_reason = ai_info.get("rationale", "")

                final_signal = signal
                final_confidence = confidence
                origin = "Technical"
                marker = "⚙️"

                if decision == "CONFIRMAR":
                    marker = "✅"
                    origin = "AI"
                    if ai_conf is not None:
                        final_confidence = (final_confidence + ai_conf) / 2
                    final_confidence, notes = _refine_confidence(final_signal, final_confidence, ctx)
                    if notes:
                        ai_reason = f"{ai_reason} | {'; '.join(notes)}" if ai_reason else '; '.join(notes)
                elif decision == "INVERSA":
                    marker = "⚠️"
                    origin = "AI"
                    final_signal = "PUT" if signal == "CALL" else "CALL"
                    final_confidence = ai_conf if ai_conf is not None else max(0.4, confidence * 0.9)
                    final_confidence, notes = _refine_confidence(final_signal, final_confidence, ctx)
                    if notes:
                        ai_reason = f"{ai_reason} | {'; '.join(notes)}" if ai_reason else '; '.join(notes)
                elif decision == "RECHAZAR":
                    marker = "❌"
                    origin = "AI"
                    final_signal = "SKIP"
                    final_confidence = ai_conf if ai_conf is not None else confidence
                else:
                    final_signal, final_confidence, fallback_notes = _fallback_decision(self.symbol, signal, confidence, ctx)
                    if fallback_notes:
                        ai_reason = fallback_notes

                final_confidence, history_notes = adjust_confidence_with_history(self.symbol, final_confidence, self.trade_history)
                if history_notes:
                    extra = " | ".join(history_notes)
                    ai_reason = f"{ai_reason} | {extra}" if ai_reason else extra

                logging.info(
                    f"[{self.symbol}] Confidence: {final_confidence:.2f} | Decision: {final_signal} | EMA: {ctx['ema_slope']:+.4f} | RSI: {ctx['rsi']:.2f} ({ctx['rsi_trend']}) | Divergence: {ctx['divergence']} | Fuente: {origin} {marker} {ai_reason}"
                )

                if final_signal == "SKIP" or final_confidence < 0.35:
                    payload = {
                        "final_decision": "SKIP",
                        "trade_result": "OMITIDO",
                        "source": origin,
                        "ai_confidence": ai_conf,
                        "ai_rationale": ai_reason,
                        "final_confidence": final_confidence,
                    }
                    self.sig.upd.emit(row_id, json.dumps(payload), "$0.00")
                    self.trade_history.append({
                        "time": timestamp,
                        "decision": "SKIP",
                        "result": "SKIP",
                        "confidence": final_confidence,
                        "source": origin,
                    })
                    time.sleep(2)
                    continue

                contract_id, price = self.api.buy(self.symbol, final_signal)
                if contract_id is None:
                    payload = {
                        "final_decision": final_signal,
                        "trade_result": "ERROR",
                        "source": origin,
                        "ai_confidence": ai_conf,
                        "ai_rationale": ai_reason,
                        "final_confidence": final_confidence,
                    }
                    self.sig.upd.emit(row_id, json.dumps(payload), "$0.00")
                    time.sleep(2)
                    continue

                result = "WIN" if np.random.rand() > 0.5 else "LOSS"
                pnl = STAKE * (0.9 if result == "WIN" else -1)

                self.ops += 1
                if result == "WIN":
                    self.win += 1
                else:
                    self.loss += 1
                self.pnl += pnl
                accuracy = (self.win / self.ops * 100) if self.ops else 0.0

                trade_record = {
                    "time": timestamp,
                    "decision": final_signal,
                    "result": result,
                    "confidence": round(final_confidence, 2),
                    "source": origin,
                }
                self.trade_history.append(trade_record)

                payload = {
                    "final_decision": final_signal,
                    "trade_result": result,
                    "source": origin,
                    "ai_confidence": ai_conf,
                    "ai_rationale": ai_reason,
                    "final_confidence": final_confidence,
                }
                self.sig.upd.emit(row_id, json.dumps(payload), f"${pnl:.2f}")
                self.sig.stats.emit(self.ops, self.win, self.loss, self.pnl, accuracy)

                time.sleep(2)
            except Exception as exc:
                logging.warning(f"[{self.symbol}] Error en ciclo de worker: {exc}")
                self.sig.status.emit(f"{self.symbol}: {exc}")
                time.sleep(3)


class Bot(QtCore.QThread):
    def __init__(self, sig: Sig, smart_mode: bool) -> None:
        super().__init__()
        self.sig = sig
        self.api = Deriv(APP_ID, API_TOKEN)
        self.workers: List[Worker] = []
        self.smart_mode = smart_mode

    def run(self) -> None:
        self.api.connect()
        symbols = self.api.valid_symbols()[:MAX_CONCURRENT_SYMBOLS]
        self.sig.status.emit("🚀 Operando en: " + ", ".join(symbols))
        offset = 0
        for symbol in symbols:
            worker = Worker(symbol, self.api, self.sig, offset, self.smart_mode)
            self.workers.append(worker)
            worker.start()
            offset += 2000


# =====================================
# INTERFAZ GRÁFICA
# =====================================
class UI(QtWidgets.QWidget):
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("💹 Deriv Bot v8.0 — IA estable + aprendizaje adaptativo")
        self.resize(1280, 720)
        self.setStyleSheet(
            """
            QWidget { background:#0a0f1a; color:#b3e5ff; font:11pt 'Consolas'; }
            QPushButton { background:#2196f3; color:white; border-radius:6px; padding:8px 14px; }
            QPushButton:hover { background:#64b5f6; }
            QTableWidget { background:#101820; color:#b3e5ff; gridline-color:#25455e; }
            QHeaderView::section { background:#1976d2; color:white; padding:6px; border:none; }
            QCheckBox { color:#b3e5ff; }
            QLabel#aiStatus { font-weight:bold; }
            """
        )

        layout = QtWidgets.QVBoxLayout(self)
        header = QtWidgets.QHBoxLayout()
        self.start_btn = QtWidgets.QPushButton("▶️ Iniciar")
        self.start_btn.clicked.connect(self.toggle)
        self.status_lbl = QtWidgets.QLabel("🟡 Inactivo")
        self.ai_status_lbl = QtWidgets.QLabel("AI status")
        self.ai_status_lbl.setObjectName("aiStatus")
        self.ai_status_lbl.setText("🚫 AI Offline")
        self.smart_mode_chk = QtWidgets.QCheckBox("Smart Mode")
        self.smart_mode_chk.setChecked(SMART_MODE_DEFAULT)
        header.addWidget(self.start_btn)
        header.addWidget(self.smart_mode_chk)
        header.addWidget(self.status_lbl)
        header.addWidget(self.ai_status_lbl)
        layout.addLayout(header)

        self.table = QtWidgets.QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels([
            "Hora",
            "Símbolo",
            "Decisión",
            "Resultado",
            "PnL",
            "Conf. IA",
            "Razon IA",
        ])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        stats_layout = QtWidgets.QHBoxLayout()
        self.ops_lbl = QtWidgets.QLabel("Ops: 0")
        self.win_lbl = QtWidgets.QLabel("Win: 0")
        self.loss_lbl = QtWidgets.QLabel("Loss: 0")
        self.pnl_lbl = QtWidgets.QLabel("PnL: $0.00")
        self.acc_lbl = QtWidgets.QLabel("Precisión: 0.0%")
        for widget in [self.ops_lbl, self.win_lbl, self.loss_lbl, self.pnl_lbl, self.acc_lbl]:
            stats_layout.addWidget(widget)
        layout.addLayout(stats_layout)

        self.sig = Sig()
        self.sig.status.connect(self.status_lbl.setText)
        self.sig.ai_status.connect(self.ai_status_lbl.setText)
        self.sig.add.connect(self.add_row)
        self.sig.upd.connect(self.update_row)
        self.sig.stats.connect(self.update_stats)

        self.bot: Optional[Bot] = None
        self.row_map: Dict[int, int] = {}

    def add_row(self, data: List[Any]) -> None:
        if not data:
            return
        row_id = data[0]
        values = data[1:]
        row = self.table.rowCount()
        self.table.insertRow(row)
        for col, value in enumerate(values):
            item = QtWidgets.QTableWidgetItem(value)
            if col == 2:
                item.setBackground(QtGui.QColor("#455A64"))
            if col == 3:
                item.setBackground(QtGui.QColor("#FFC107"))
            self.table.setItem(row, col, item)
        self.row_map[row_id] = row

    def _color_result_cell(self, row: int, text: str) -> None:
        item = self.table.item(row, 3)
        if item is None:
            item = QtWidgets.QTableWidgetItem(text)
            self.table.setItem(row, 3, item)
        if "WIN" in text:
            item.setBackground(QtGui.QColor("#1B5E20"))
        elif "LOSS" in text:
            item.setBackground(QtGui.QColor("#B71C1C"))
        elif "Pendiente" in text or "Analizando" in text:
            item.setBackground(QtGui.QColor("#FFC107"))
        else:
            item.setBackground(QtGui.QColor("#455A64"))
        item.setText(text)

    def update_row(self, row_id: int, payload: str, pnl: str) -> None:
        row = self.row_map.get(row_id)
        if row is None:
            return
        try:
            data = json.loads(payload)
        except Exception:
            data = {}
        decision = data.get("final_decision", "")
        final_conf = data.get("final_confidence")
        if decision:
            decision_text = decision
            if final_conf is not None:
                decision_text = f"{decision} ({final_conf:.2f})"
            self.table.setItem(row, 2, QtWidgets.QTableWidgetItem(decision_text))
        result = data.get("trade_result", "-")
        self._color_result_cell(row, result)
        self.table.setItem(row, 4, QtWidgets.QTableWidgetItem(pnl))
        ai_conf = data.get("ai_confidence")
        ai_text = "—" if ai_conf is None else f"{ai_conf:.2f}"
        self.table.setItem(row, 5, QtWidgets.QTableWidgetItem(ai_text))
        rationale = data.get("ai_rationale", "")
        self.table.setItem(row, 6, QtWidgets.QTableWidgetItem(rationale))

    def update_stats(self, ops: int, wins: int, losses: int, pnl: float, accuracy: float) -> None:
        self.ops_lbl.setText(f"Ops: {ops}")
        self.win_lbl.setText(f"Win: {wins}")
        self.loss_lbl.setText(f"Loss: {losses}")
        self.pnl_lbl.setText(f"PnL: ${pnl:.2f}")
        self.acc_lbl.setText(f"Precisión: {accuracy:.1f}%")

    def toggle(self) -> None:
        if self.bot:
            return
        smart_mode = self.smart_mode_chk.isChecked()
        self.bot = Bot(self.sig, smart_mode)
        self.bot.start()
        self.status_lbl.setText("✅ Operando")
        self.start_btn.setDisabled(True)


def main() -> None:
    app = QtWidgets.QApplication(sys.argv)
    ui = UI()
    ui.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
